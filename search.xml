<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇文章</title>
    <url>/2025/04/08/2025-4-8-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[第一篇文章内容


        
          时间轴样式

        
      
        
          2020-07-24 2.6.6 -&gt; 3.0

        
        
如果有 hexo-lazyload-image 插件，需要删除并重新安装最新版本，设置 lazyload.isSPA: true。
2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 use_cdn: true 则需要删除。
2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。
2.x 版本的置顶 top: true 改为了 pin: true，并且同样适用于 layout: page 的页面。
如果使用了 hexo-offline 插件，建议卸载，3.0 版本默认开启了 pjax 服务。


      ]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
  </entry>
  <entry>
    <title>第三篇文章</title>
    <url>/2025/04/08/2025-4-8-%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[第三篇文章]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>异常&amp;File</title>
    <url>/2025/04/10/IO-%E5%BC%82%E5%B8%B8-File-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[1. 异常1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：

异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。

在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。

异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.

1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。

Throwable体系：

Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。
Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。

Throwable中的常用方法：

public void printStackTrace():打印异常的详细信息。
包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。

public String getMessage():获取发生异常的原因。
提示给用户的时候,就提示错误原因。

public String toString():获取异常的类型和异常描述信息(不用)。


出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。

1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。
异常(Exception)的分类:根据在编译时期还是运行时期去检查异常?

编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)
运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)

​    
1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。
 工具类
public class ArrayTools &#123;    // 对给定的数组通过给定的角标获取元素。    public static int getElement(int[] arr, int index) &#123;        int element = arr[index];        return element;    &#125;&#125;
 测试类
public class ExceptionDemo &#123;    public static void main(String[] args) &#123;        int[] arr = &#123; 34, 12, 67 &#125;;        intnum = ArrayTools.getElement(arr, 4)        System.out.println(&quot;num=&quot; + num);        System.out.println(&quot;over&quot;);    &#125;&#125;
上述程序执行过程图解：
 
1.5 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。
在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？

创建一个异常对象。封装一些提示信息(信息可以自己编写)。

需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。
throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。


使用格式：
throw new 异常类名(参数);
 例如：
throw new NullPointerException(&quot;要访问的arr数组不存在&quot;);throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;);
学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。
public class ThrowDemo &#123;    public static void main(String[] args) &#123;        //创建一个数组         int[] arr = &#123;2,4,52,2&#125;;        //根据索引找对应的元素         int index = 4;        int element = getElement(arr, index);        System.out.println(element);        System.out.println(&quot;over&quot;);    &#125;    /*     * 根据 索引找到数组中对应的元素     */    public static int getElement(int[] arr,int index)&#123;        	//判断  索引是否越界        if(index&lt;0 || index&gt;arr.length-1)&#123;             /*             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。               */             throw new ArrayIndexOutOfBoundsException(&quot;哥们，角标越界了```&quot;);        &#125;        int element = arr[index];        return element;    &#125;&#125;

注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。
那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。

1.6 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。
关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).
声明异常格式：
修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;	
声明异常的代码演示：
public class ThrowsDemo &#123;    public static void main(String[] args) throws FileNotFoundException &#123;        read(&quot;a.txt&quot;);    &#125;    // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明    public static void read(String path) throws FileNotFoundException &#123;        if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件             // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw            throw new FileNotFoundException(&quot;文件不存在&quot;);        &#125;    &#125;&#125;
throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。
public class ThrowsDemo2 &#123;    public static void main(String[] args) throws IOException &#123;        read(&quot;a.txt&quot;);    &#125;    public static void read(String path)throws FileNotFoundException, IOException &#123;        if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件             // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw            throw new FileNotFoundException(&quot;文件不存在&quot;);        &#125;        if (!path.equals(&quot;b.txt&quot;)) &#123;            throw new IOException();        &#125;    &#125;&#125;
1.7 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常:

该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。
在方法中使用try-catch的语句块来处理异常。

try-catch的方式就是捕获异常。

捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。

捕获异常语法如下：
try&#123;     编写可能会出现异常的代码&#125;catch(异常类型  e)&#123;     处理异常的代码     //记录日志/打印异常信息/继续抛出异常&#125;
try：该代码块中编写可能产生异常的代码。
catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。

注意:try和catch都不能单独使用,必须连用。

演示如下：
public class TryCatchDemo &#123;    public static void main(String[] args) &#123;        try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。            read(&quot;b.txt&quot;);        &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？          	//try中抛出的是什么异常，在括号中就定义什么异常类型            System.out.println(e);        &#125;        System.out.println(&quot;over&quot;);    &#125;    /*     *     * 我们 当前的这个方法中 有异常  有编译期异常     */    public static void read(String path) throws FileNotFoundException &#123;        if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件             // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw            throw new FileNotFoundException(&quot;文件不存在&quot;);        &#125;    &#125;&#125;
如何获取异常信息：
Throwable类中定义了一些查看方法:

public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。


public String toString():获取异常的类型和异常描述信息(不用)。
public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。

​            包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。
在开发中呢也可以在catch将编译期异常转换成运行期异常处理。
多个异常使用捕获又该如何处理呢？

多个异常分别处理。
多个异常一次捕获，多次处理。
多个异常一次捕获一次处理。

一般我们是使用一次捕获多次处理方式，格式如下：
try&#123;     编写可能会出现异常的代码&#125;catch(异常类型A  e)&#123;  当try中出现A类型异常,就用该catch来捕获.     处理异常的代码     //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B  e)&#123;  当try中出现B类型异常,就用该catch来捕获.     处理异常的代码     //记录日志/打印异常信息/继续抛出异常&#125;

注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。

1.8 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。
什么时候的代码必须最终执行？
当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。
finally的语法:
 try…catch….finally:自身需要处理异常,最终还得关闭资源。

注意:finally不能单独使用。

比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。
finally代码参考如下：
public class TryCatchDemo4 &#123;    public static void main(String[] args) &#123;        try &#123;            read(&quot;a.txt&quot;);        &#125; catch (FileNotFoundException e) &#123;            //抓取到的是编译期异常  抛出去的是运行期             throw new RuntimeException(e);        &#125; finally &#123;            System.out.println(&quot;不管程序怎样，这里都将会被执行。&quot;);        &#125;        System.out.println(&quot;over&quot;);    &#125;    /*     *     * 我们 当前的这个方法中 有异常  有编译期异常     */    public static void read(String path) throws FileNotFoundException &#123;        if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件             // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw            throw new FileNotFoundException(&quot;文件不存在&quot;);        &#125;    &#125;&#125;

当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。

1.9 异常注意事项
运行时异常被抛出可以不处理。即不捕获也不声明抛出。
如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。
父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出
当多异常处理时，捕获处理，前边的类不能是后边类的父类
在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。

1.10 概述为什么需要自定义异常类:
我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。
在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？
什么是自定义异常类:
在开发中根据自己业务的异常情况来定义异常类.
自定义一个业务逻辑异常: LoginException。一个登陆异常类。
异常类如何定义:

自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。
自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。

1.11 自定义异常的练习要求：我们模拟登陆操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。
首先定义一个登陆异常类LoginException：
// 业务逻辑异常public class LoginException extends Exception &#123;    /**     * 空参构造     */    public LoginException() &#123;    &#125;    /**     *     * @param message 表示异常提示     */    public LoginException(String message) &#123;        super(message);    &#125;&#125;
模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。
public class Demo &#123;    // 模拟数据库中已存在账号    private static String[] names = &#123;&quot;bill&quot;,&quot;hill&quot;,&quot;jill&quot;&#125;;       public static void main(String[] args) &#123;             //调用方法        try&#123;            // 可能出现异常的代码            checkUsername(&quot;nill&quot;);            System.out.println(&quot;注册成功&quot;);//如果没有异常就是注册成功        &#125; catch(LoginException e) &#123;            //处理异常            e.printStackTrace();        &#125;    &#125;    //判断当前注册账号是否存在    //因为是编译期异常，又想调用者去处理 所以声明该异常    public static boolean checkUsername(String uname) throws LoginException &#123;        for (String name : names) &#123;            if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常                throw new LoginException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;);            &#125;        &#125;        return true;    &#125;&#125;
2. File类2.1 概述java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。
2.2 构造方法
public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。  
public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。
public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。  
构造举例，代码如下：

// 文件路径名String pathname = &quot;D:\\aaa.txt&quot;;File file1 = new File(pathname); // 文件路径名String pathname2 = &quot;D:\\aaa\\bbb.txt&quot;;File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = &quot;d:\\aaa&quot;; String child = &quot;bbb.txt&quot;; File file3 = new File(parent, child);// 通过父级File对象和子路径字符串File parentDir = new File(&quot;d:\\aaa&quot;);String child = &quot;bbb.txt&quot;;File file4 = new File(parentDir, child);

小贴士：

一个File对象代表硬盘中实际存在的一个文件或者目录。
无论该路径下是否存在文件或者目录，都不影响File对象的创建。


2.3 常用方法获取功能的方法
public String getAbsolutePath() ：返回此File的绝对路径名字符串。

public String getPath() ：将此File转换为路径名字符串。 

public String getName()  ：返回由此File表示的文件或目录的名称。  

public long length()  ：返回由此File表示的文件的长度。 
方法演示，代码如下：
public class FileGet &#123;    public static void main(String[] args) &#123;        File f = new File(&quot;d:/aaa/bbb.java&quot;);             System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath());        System.out.println(&quot;文件构造路径:&quot;+f.getPath());        System.out.println(&quot;文件名称:&quot;+f.getName());        System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;);        File f2 = new File(&quot;d:/aaa&quot;);             System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath());        System.out.println(&quot;目录构造路径:&quot;+f2.getPath());        System.out.println(&quot;目录名称:&quot;+f2.getName());        System.out.println(&quot;目录长度:&quot;+f2.length());    &#125;&#125;输出结果：文件绝对路径:d:\aaa\bbb.java文件构造路径:d:\aaa\bbb.java文件名称:bbb.java文件长度:636字节目录绝对路径:d:\aaa目录构造路径:d:\aaa目录名称:aaa目录长度:4096



API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。

绝对路径和相对路径
绝对路径：从盘符开始的路径，这是一个完整的路径。
相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。

public class FilePath &#123;    public static void main(String[] args) &#123;      	// D盘下的bbb.java文件        File f = new File(&quot;D:\\bbb.java&quot;);        System.out.println(f.getAbsolutePath());      			// 项目下的bbb.java文件        File f2 = new File(&quot;bbb.java&quot;);        System.out.println(f2.getAbsolutePath());    &#125;&#125;输出结果：D:\bbb.javaD:\idea_project_test4\bbb.java
判断功能的方法
public boolean exists() ：此File表示的文件或目录是否实际存在。
public boolean isDirectory() ：此File表示的是否为目录。
public boolean isFile() ：此File表示的是否为文件。

方法演示，代码如下：
public class FileIs &#123;    public static void main(String[] args) &#123;        File f = new File(&quot;d:\\aaa\\bbb.java&quot;);        File f2 = new File(&quot;d:\\aaa&quot;);      	// 判断是否存在        System.out.println(&quot;d:\\aaa\\bbb.java 是否存在:&quot;+f.exists());        System.out.println(&quot;d:\\aaa 是否存在:&quot;+f2.exists());      	// 判断是文件还是目录        System.out.println(&quot;d:\\aaa 文件?:&quot;+f2.isFile());        System.out.println(&quot;d:\\aaa 目录?:&quot;+f2.isDirectory());    &#125;&#125;输出结果：d:\aaa\bbb.java 是否存在:trued:\aaa 是否存在:trued:\aaa 文件?:falsed:\aaa 目录?:true
创建删除功能的方法
public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 
public boolean delete() ：删除由此File表示的文件或目录。  
public boolean mkdir() ：创建由此File表示的目录。
public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。

方法演示，代码如下：
public class FileCreateDelete &#123;    public static void main(String[] args) throws IOException &#123;        // 文件的创建        File f = new File(&quot;aaa.txt&quot;);        System.out.println(&quot;是否存在:&quot;+f.exists()); // false        System.out.println(&quot;是否创建:&quot;+f.createNewFile()); // true        System.out.println(&quot;是否存在:&quot;+f.exists()); // true		     	// 目录的创建      	File f2= new File(&quot;newDir&quot;);	        System.out.println(&quot;是否存在:&quot;+f2.exists());// false        System.out.println(&quot;是否创建:&quot;+f2.mkdir());	// true        System.out.println(&quot;是否存在:&quot;+f2.exists());// true		// 创建多级目录      	File f3= new File(&quot;newDira\\newDirb&quot;);        System.out.println(f3.mkdir());// false        File f4= new File(&quot;newDira\\newDirb&quot;);        System.out.println(f4.mkdirs());// true            	// 文件的删除       	System.out.println(f.delete());// true            	// 目录的删除        System.out.println(f2.delete());// true        System.out.println(f4.delete());// false    &#125;&#125;

API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。

2.4 目录的遍历
public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。
public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。  

public class FileFor &#123;    public static void main(String[] args) &#123;        File dir = new File(&quot;d:\\java_code&quot;);            	//获取当前目录下的文件以及文件夹的名称。		String[] names = dir.list();		for(String name : names)&#123;			System.out.println(name);		&#125;        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息        File[] files = dir.listFiles();        for (File file : files) &#123;            System.out.println(file);        &#125;    &#125;&#125;

小贴士：
调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。

2.5 综合练习练习1：创建文件夹​    在当前模块下的aaa文件夹中创建一个a.txt文件
代码实现：
public class Test1 &#123;    public static void main(String[] args) throws IOException &#123;        //需求：在当前模块下的aaa文件夹中创建一个a.txt文件        //1.创建a.txt的父级路径        File file = new File(&quot;myfile\\aaa&quot;);        //2.创建父级路径        //如果aaa是存在的，那么此时创建失败的。        //如果aaa是不存在的，那么此时创建成功的。        file.mkdirs();        //3.拼接父级路径和子级路径        File src = new File(file,&quot;a.txt&quot;);        boolean b = src.createNewFile();        if(b)&#123;            System.out.println(&quot;创建成功&quot;);        &#125;else&#123;            System.out.println(&quot;创建失败&quot;);        &#125;    &#125;&#125;
练习2：查找文件（不考虑子文件夹）​    定义一个方法找某一个文件夹中，是否有以avi结尾的电影（暂时不需要考虑子文件夹）
代码示例：
public class Test2 &#123;    public static void main(String[] args) &#123;        /*需求：             定义一个方法找某一个文件夹中，是否有以avi结尾的电影。	        （暂时不需要考虑子文件夹）        */        File file = new File(&quot;D:\\aaa\\bbb&quot;);        boolean b = haveAVI(file);        System.out.println(b);    &#125;    /*    * 作用：用来找某一个文件夹中，是否有以avi结尾的电影    * 形参：要查找的文件夹    * 返回值：查找的结果  存在true  不存在false    * */    public static boolean haveAVI(File file)&#123;// D:\\aaa        //1.进入aaa文件夹，而且要获取里面所有的内容        File[] files = file.listFiles();        //2.遍历数组获取里面的每一个元素        for (File f : files) &#123;            //f：依次表示aaa文件夹里面每一个文件或者文件夹的路径            if(f.isFile() &amp;&amp; f.getName().endsWith(&quot;.avi&quot;))&#123;                return true;            &#125;        &#125;        //3.如果循环结束之后还没有找到，直接返回false        return false;    &#125;&#125;
练习3：（考虑子文件夹）​    找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）
代码示例：
public class Test3 &#123;    public static void main(String[] args) &#123;        /* 需求：        找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）        套路：            1，进入文件夹            2，遍历数组            3，判断            4，判断        */        findAVI();    &#125;    public static void findAVI()&#123;        //获取本地所有的盘符        File[] arr = File.listRoots();        for (File f : arr) &#123;            findAVI(f);        &#125;    &#125;    public static void findAVI(File src)&#123;//&quot;C:\\        //1.进入文件夹src        File[] files = src.listFiles();        //2.遍历数组,依次得到src里面每一个文件或者文件夹        if(files != null)&#123;            for (File file : files) &#123;                if(file.isFile())&#123;                    //3，判断，如果是文件，就可以执行题目的业务逻辑                    String name = file.getName();                    if(name.endsWith(&quot;.avi&quot;))&#123;                        System.out.println(file);                    &#125;                &#125;else&#123;                    //4，判断，如果是文件夹，就可以递归                    //细节：再次调用本方法的时候，参数一定要是src的次一级路径                    findAVI(file);                &#125;            &#125;        &#125;    &#125;&#125;
练习4：删除多级文件夹需求： 如果我们要删除一个有内容的文件夹       1.先删除文件夹里面所有的内容           2.再删除自己
代码示例：
public class Test4 &#123;    public static void main(String[] args) &#123;        /*           删除一个多级文件夹           如果我们要删除一个有内容的文件夹           1.先删除文件夹里面所有的内容           2.再删除自己        */        File file = new File(&quot;D:\\aaa\\src&quot;);        delete(file);    &#125;    /*    * 作用：删除src文件夹    * 参数：要删除的文件夹    * */    public static void delete(File src)&#123;        //1.先删除文件夹里面所有的内容        //进入src        File[] files = src.listFiles();        //遍历        for (File file : files) &#123;            //判断,如果是文件，删除            if(file.isFile())&#123;                file.delete();            &#125;else &#123;                //判断,如果是文件夹，就递归                delete(file);            &#125;        &#125;        //2.再删除自己        src.delete();    &#125;&#125;
练习5：统计大小​    需求：统计一个文件夹的总大小
代码示例：
public class Test5 &#123;    public static void main(String[] args) &#123;       /*需求：            统计一个文件夹的总大小      */        File file = new File(&quot;D:\\aaa\\src&quot;);        long len = getLen(file);        System.out.println(len);//4919189    &#125;    /*    * 作用：    *       统计一个文件夹的总大小    * 参数：    *       表示要统计的那个文件夹    * 返回值：    *       统计之后的结果    *    * 文件夹的总大小：    *       说白了，文件夹里面所有文件的大小    * */    public static long getLen(File src)&#123;        //1.定义变量进行累加        long len = 0;        //2.进入src文件夹        File[] files = src.listFiles();        //3.遍历数组        for (File file : files) &#123;            //4.判断            if(file.isFile())&#123;                //我们就把当前文件的大小累加到len当中                len = len + file.length();            &#125;else&#123;                //判断，如果是文件夹就递归                len = len + getLen(file);            &#125;        &#125;        return len;    &#125;&#125;
练习6：统计文件个数  需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）            打印格式如下：            txt:3个            doc:4个            jpg:6个
代码示例：
public class Test6 &#123;    public static void main(String[] args) throws IOException &#123;        /*            需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）            打印格式如下：            txt:3个            doc:4个            jpg:6个        */        File file = new File(&quot;D:\\aaa\\src&quot;);        HashMap&lt;String, Integer&gt; hm = getCount(file);        System.out.println(hm);    &#125;    /*    * 作用：    *       统计一个文件夹中每种文件的个数    * 参数：    *       要统计的那个文件夹    * 返回值：    *       用来统计map集合    *       键：后缀名 值：次数    *    *       a.txt    *       a.a.txt    *       aaa（不需要统计的）    *    *    * */    public static HashMap&lt;String,Integer&gt; getCount(File src)&#123;        //1.定义集合用来统计        HashMap&lt;String,Integer&gt; hm = new HashMap&lt;&gt;();        //2.进入src文件夹        File[] files = src.listFiles();        //3.遍历数组        for (File file : files) &#123;            //4.判断，如果是文件，统计            if(file.isFile())&#123;                //a.txt                String name = file.getName();                String[] arr = name.split(&quot;\\.&quot;);                if(arr.length &gt;= 2)&#123;                    String endName = arr[arr.length - 1];                    if(hm.containsKey(endName))&#123;                        //存在                        int count = hm.get(endName);                        count++;                        hm.put(endName,count);                    &#125;else&#123;                        //不存在                        hm.put(endName,1);                    &#125;                &#125;            &#125;else&#123;                //5.判断，如果是文件夹，递归                //sonMap里面是子文件中每一种文件的个数                HashMap&lt;String, Integer&gt; sonMap = getCount(file);                //hm:  txt=1  jpg=2  doc=3                //sonMap: txt=3 jpg=1                //遍历sonMap把里面的值累加到hm当中                Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = sonMap.entrySet();                for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;                    String key = entry.getKey();                    int value = entry.getValue();                    if(hm.containsKey(key))&#123;                        //存在                        int count = hm.get(key);                        count = count + value;                        hm.put(key,count);                    &#125;else&#123;                        //不存在                        hm.put(key,value);                    &#125;                &#125;            &#125;        &#125;        return hm;    &#125;&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>第二篇文章</title>
    <url>/2025/04/08/2025-4-8-%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[第二篇文章]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>IO流--扩展流</title>
    <url>/2025/04/10/IO%E6%B5%81-%E5%85%B6%E4%BB%96%E6%B5%81/</url>
    <content><![CDATA[1. 缓冲流昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。
1.1 概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类：

字节缓冲流：BufferedInputStream，BufferedOutputStream 
字符缓冲流：BufferedReader，BufferedWriter

缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。
1.2 字节缓冲流构造方法
public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 
public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。

构造举例，代码如下：
// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;));
效率测试查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。

基本流，代码如下：

public class BufferedDemo &#123;    public static void main(String[] args) throws FileNotFoundException &#123;        // 记录开始时间      	long start = System.currentTimeMillis();		// 创建流对象        try (        	FileInputStream fis = new FileInputStream(&quot;jdk9.exe&quot;);        	FileOutputStream fos = new FileOutputStream(&quot;copy.exe&quot;)        )&#123;        	// 读写数据            int b;            while ((b = fis.read()) != -1) &#123;                fos.write(b);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;		// 记录结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);    &#125;&#125;十几分钟过去了...

缓冲流，代码如下：

public class BufferedDemo &#123;    public static void main(String[] args) throws FileNotFoundException &#123;        // 记录开始时间      	long start = System.currentTimeMillis();		// 创建流对象        try (        	BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));	     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));        )&#123;        // 读写数据            int b;            while ((b = bis.read()) != -1) &#123;                bos.write(b);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;		// 记录结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);    &#125;&#125;缓冲流复制时间:8016 毫秒
如何更快呢？
使用数组的方式，代码如下：
public class BufferedDemo &#123;    public static void main(String[] args) throws FileNotFoundException &#123;      	// 记录开始时间        long start = System.currentTimeMillis();		// 创建流对象        try (			BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));		 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));        )&#123;          	// 读写数据            int len;            byte[] bytes = new byte[8*1024];            while ((len = bis.read(bytes)) != -1) &#123;                bos.write(bytes, 0 , len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;		// 记录结束时间        long end = System.currentTimeMillis();        System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);    &#125;&#125;缓冲流使用数组复制时间:666 毫秒
1.3 字符缓冲流构造方法
public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 
public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。

构造举例，代码如下：
// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(&quot;br.txt&quot;));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;));
特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。

BufferedReader：public String readLine(): 读一行文字。 
BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 

readLine方法演示，代码如下：
public class BufferedReaderDemo &#123;    public static void main(String[] args) throws IOException &#123;      	 // 创建流对象        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));		// 定义字符串,保存读取的一行文字        String line  = null;      	// 循环读取,读取到最后返回null        while ((line = br.readLine())!=null) &#123;            System.out.print(line);            System.out.println(&quot;------&quot;);        &#125;		// 释放资源        br.close();    &#125;&#125;
newLine方法演示，代码如下：
  public class BufferedWriterDemo throws IOException &#123;    public static void main(String[] args) throws IOException  &#123;      	// 创建流对象		BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));      	// 写出数据        bw.write(&quot;黑马&quot;);      	// 写出换行        bw.newLine();        bw.write(&quot;程序&quot;);        bw.newLine();        bw.write(&quot;员&quot;);        bw.newLine();		// 释放资源        bw.close();    &#125;&#125;输出效果:黑马程序员
1.4 练习:文本排序请将文本信息恢复顺序。
3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。
案例分析
逐行读取文本信息。
把读取到的文本存储到集合中
对集合中的文本进行排序
遍历集合，按顺序，写出文本信息。

案例实现public class Demo05Test &#123;    public static void main(String[] args) throws IOException &#123;        //1.创建ArrayList集合,泛型使用String        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        //2.创建BufferedReader对象,构造方法中传递FileReader对象        BufferedReader br = new BufferedReader(new FileReader(&quot;10_IO\\in.txt&quot;));        //3.创建BufferedWriter对象,构造方法中传递FileWriter对象        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;10_IO\\out.txt&quot;));        //4.使用BufferedReader对象中的方法readLine,以行的方式读取文本        String line;        while((line = br.readLine())!=null)&#123;            //5.把读取到的文本存储到ArrayList集合中            list.add(line);        &#125;        //6.使用Collections集合工具类中的方法sort,对集合中的元素按照自定义规则排序        Collections.sort(list, new Comparator&lt;String&gt;() &#123;            /*                o1-o2:升序                o2-o1:降序             */            @Override            public int compare(String o1, String o2) &#123;                //依次比较集合中两个元素的首字母,升序排序                return o1.charAt(0)-o2.charAt(0);            &#125;        &#125;);        //7.遍历ArrayList集合,获取每一个元素        for (String s : list) &#123;            //8.使用BufferedWriter对象中的方法wirte,把遍历得到的元素写入到文本中(内存缓冲区中)            bw.write(s);            //9.写换行            bw.newLine();        &#125;        //10.释放资源        bw.close();        br.close();    &#125;&#125;
基本流：
1.字节流
2.字符流：底层：字符流 = 字节流 + 字符集，底层自带8192字节数组的缓冲区
高级流：
1.缓冲字节输入流：底层自带8192字节数组的缓冲区
2.缓冲字节输出流：底层自带8192字节数组的缓冲区
3.缓冲字符输入流：底层自带8192字符数组的缓冲区
4.缓冲字符输出流：底层自带8192字符数组的缓冲区
读写数据都是先处理缓冲区中的数据：
读：从磁盘文件先读到内存的缓冲区，第一次有多少读多少，将缓冲区填满，再从缓冲区读
写：从缓冲区拿数据写入磁盘文件
字符集：
ASCII（英文）-&gt; GB（中文）-&gt; GBK （扩展）-&gt; Unicode（万国码）
ASCII：英文：一个字节，左补0
GBK：英文：一个字节，左补0，中文：两个字节
Unicode：英文：一个字节，左补0，中文（UTF-8编码方式）：三个字节
eclipse默认GBK
 IDEA默认UTF-8
2. 转换流2.1 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。
编码:字符(能看懂的)—字节(看不懂的)
解码:字节(看不懂的)—&gt;字符(能看懂的)

字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。
编码表:生活中文字和计算机中二进制的对应规则


字符集
字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。

计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。
可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。

ASCII字符集 ：
ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。
基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。


ISO-8859-1字符集：
拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。
ISO-8859-1使用单字节编码，兼容ASCII编码。


GBxxx字符集：
GB就是国标的意思，是为了显示中文而设计的一套字符集。
GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。
GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。
GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。


Unicode字符集 ：
Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。
它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。
UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：
128个US-ASCII字符，只需一个字节编码。
拉丁文等字符，需要二个字节编码。 
大部分常用字（含中文），使用三个字节编码。
其他极少使用的Unicode辅助字符，使用四字节编码。





2.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。
public class ReaderDemo &#123;    public static void main(String[] args) throws IOException &#123;        FileReader fileReader = new FileReader(&quot;E:\\File_GBK.txt&quot;);        int read;        while ((read = fileReader.read()) != -1) &#123;            System.out.print((char)read);        &#125;        fileReader.close();    &#125;&#125;输出结果：���
那么如何读取GBK编码的文件呢？ 
2.3 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 
构造方法
InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 
InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。

构造举例，代码如下： 
InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;);
指定编码读取public class ReaderDemo2 &#123;    public static void main(String[] args) throws IOException &#123;      	// 定义文件路径,文件为gbk编码        String FileName = &quot;E:\\file_gbk.txt&quot;;      	// 创建流对象,默认UTF8编码        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));      	// 创建流对象,指定GBK编码        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , &quot;GBK&quot;);		// 定义变量,保存字符        int read;      	// 使用默认编码字符流读取,乱码        while ((read = isr.read()) != -1) &#123;            System.out.print((char)read); // ��Һ�        &#125;        isr.close();            	// 使用指定编码字符流读取,正常解析        while ((read = isr2.read()) != -1) &#123;            System.out.print((char)read);// 大家好        &#125;        isr2.close();    &#125;&#125;
2.4 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 
构造方法
OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 
OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。

构造举例，代码如下： 
OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;);
指定编码写出public class OutputDemo &#123;    public static void main(String[] args) throws IOException &#123;      	// 定义文件路径        String FileName = &quot;E:\\out.txt&quot;;      	// 创建流对象,默认UTF8编码        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));        // 写出数据      	osw.write(&quot;你好&quot;); // 保存为6个字节        osw.close();      			// 定义文件路径		String FileName2 = &quot;E:\\out2.txt&quot;;     	// 创建流对象,指定GBK编码        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;);        // 写出数据      	osw2.write(&quot;你好&quot;);// 保存为4个字节        osw2.close();    &#125;&#125;
转换流理解图解转换流是字节与字符间的桥梁！
2.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。
案例分析
指定GBK编码的转换流，读取文本文件。
使用UTF-8编码的转换流，写出文本文件。

案例实现public class TransDemo &#123;   public static void main(String[] args) &#123;          	// 1.定义文件路径     	String srcFile = &quot;file_gbk.txt&quot;;        String destFile = &quot;file_utf8.txt&quot;;		// 2.创建流对象    	// 2.1 转换输入流,指定GBK编码        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , &quot;GBK&quot;);    	// 2.2 转换输出流,默认utf8编码        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));		// 3.读写数据    	// 3.1 定义数组        char[] cbuf = new char[1024];    	// 3.2 定义长度        int len;    	// 3.3 循环读取        while ((len = isr.read(cbuf))!=-1) &#123;            // 循环写出          	osw.write(cbuf,0,len);        &#125;    	// 4.释放资源        osw.close();        isr.close();  	&#125;&#125;
3. 序列化3.1 概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 
反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： 
3.2 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。
构造方法
public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。

构造举例，代码如下：  
FileOutputStream fileOut = new FileOutputStream(&quot;employee.txt&quot;);ObjectOutputStream out = new ObjectOutputStream(fileOut);
序列化操作
一个对象要想序列化，必须满足两个条件:


该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。
该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。

public class Employee implements java.io.Serializable &#123;    public String name;    public String address;    public transient int age; // transient瞬态修饰成员,不会被序列化    public void addressCheck() &#123;      	System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);    &#125;&#125;
2.写出对象方法

public final void writeObject (Object obj) : 将指定的对象写出。

public class SerializeDemo&#123;   	public static void main(String [] args)   &#123;    	Employee e = new Employee();    	e.name = &quot;zhangsan&quot;;    	e.address = &quot;beiqinglu&quot;;    	e.age = 20;     	try &#123;      		// 创建序列化流对象          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));        	// 写出对象        	out.writeObject(e);        	// 释放资源        	out.close();        	fileOut.close();        	System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。        &#125; catch(IOException i)   &#123;            i.printStackTrace();        &#125;   	&#125;&#125;输出结果：Serialized data is saved
3.3 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 
构造方法
public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。

反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：

public final Object readObject () : 读取一个对象。

public class DeserializeDemo &#123;   public static void main(String [] args)   &#123;        Employee e = null;        try &#123;		             // 创建反序列化流             FileInputStream fileIn = new FileInputStream(&quot;employee.txt&quot;);             ObjectInputStream in = new ObjectInputStream(fileIn);             // 读取一个对象             e = (Employee) in.readObject();             // 释放资源             in.close();             fileIn.close();        &#125;catch(IOException i) &#123;             // 捕获其他异常             i.printStackTrace();             return;        &#125;catch(ClassNotFoundException c)  &#123;        	// 捕获类找不到异常             System.out.println(&quot;Employee class not found&quot;);             c.printStackTrace();             return;        &#125;        // 无异常,直接打印输出        System.out.println(&quot;Name: &quot; + e.name);	// zhangsan        System.out.println(&quot;Address: &quot; + e.address); // beiqinglu        System.out.println(&quot;age: &quot; + e.age); // 0    &#125;&#125;
对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。  
反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：

该类的序列版本号与从流中读取的类描述符的版本号不匹配 
该类包含未知数据类型 
该类没有可访问的无参数构造方法 

Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。
public class Employee implements java.io.Serializable &#123;     // 加入序列版本号     private static final long serialVersionUID = 1L;     public String name;     public String address;     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.     public int eid;      public void addressCheck() &#123;         System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);     &#125;&#125;
3.4 练习：序列化集合
将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。
反序列化list.txt ，并遍历集合，打印对象信息。

案例分析
把若干学生对象 ，保存到集合中。
把集合序列化。
反序列化读取时，只需要读取一次，转换为集合类型。
遍历集合，可以打印所有的学生信息

案例实现public class SerTest &#123;	public static void main(String[] args) throws Exception &#123;		// 创建 学生对象		Student student = new Student(&quot;老王&quot;, &quot;laow&quot;);		Student student2 = new Student(&quot;老张&quot;, &quot;laoz&quot;);		Student student3 = new Student(&quot;老李&quot;, &quot;laol&quot;);		ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;();		arrayList.add(student);		arrayList.add(student2);		arrayList.add(student3);		// 序列化操作		// serializ(arrayList);				// 反序列化  		ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;));		// 读取对象,强转为ArrayList类型		ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();		      	for (int i = 0; i &lt; list.size(); i++ )&#123;          	Student s = list.get(i);        	System.out.println(s.getName()+&quot;--&quot;+ s.getPwd());      	&#125;	&#125;	private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123;		// 创建 序列化流 		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;));		// 写出对象		oos.writeObject(arrayList);		// 释放资源		oos.close();	&#125;&#125;
4. 打印流4.1 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。
4.2 PrintStream类构造方法
public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。

构造举例，代码如下：  
PrintStream ps = new PrintStream(&quot;ps.txt&quot;)；
改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。
public class PrintDemo &#123;    public static void main(String[] args) throws IOException &#123;		// 调用系统的打印流,控制台直接输出97        System.out.println(97);      		// 创建打印流,指定文件的名称        PrintStream ps = new PrintStream(&quot;ps.txt&quot;);      	      	// 设置系统的打印流流向,输出到ps.txt        System.setOut(ps);      	// 调用系统的打印流,ps.txt中输出97        System.out.println(97);    &#125;&#125;
5. 压缩流和解压缩流压缩流：
​    负责压缩文件或者文件夹
解压缩流：
​    负责把压缩包中的文件和文件夹解压出来
/**   解压缩流** */public class ZipStreamDemo1 &#123;    public static void main(String[] args) throws IOException &#123;        //1.创建一个File表示要解压的压缩包        File src = new File(&quot;D:\\aaa.zip&quot;);        //2.创建一个File表示解压的目的地        File dest = new File(&quot;D:\\&quot;);        //调用方法        unzip(src,dest);    &#125;    //定义一个方法用来解压    public static void unzip(File src,File dest) throws IOException &#123;        //解压的本质：把压缩包里面的每一个文件或者文件夹读取出来，按照层级拷贝到目的地当中        //创建一个解压缩流用来读取压缩包中的数据        ZipInputStream zip = new ZipInputStream(new FileInputStream(src));        //要先获取到压缩包里面的每一个zipentry对象        //表示当前在压缩包中获取到的文件或者文件夹        ZipEntry entry;        while((entry = zip.getNextEntry()) != null)&#123;            System.out.println(entry);            if(entry.isDirectory())&#123;                //文件夹：需要在目的地dest处创建一个同样的文件夹                File file = new File(dest,entry.toString());                file.mkdirs();            &#125;else&#123;                //文件：需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放）                FileOutputStream fos = new FileOutputStream(new File(dest,entry.toString()));                int b;                while((b = zip.read()) != -1)&#123;                    //写到目的地                    fos.write(b);                &#125;                fos.close();                //表示在压缩包中的一个文件处理完毕了。                zip.closeEntry();            &#125;        &#125;        zip.close();    &#125;&#125;
public class ZipStreamDemo2 &#123;    public static void main(String[] args) throws IOException &#123;        /*         *   压缩流         *      需求：         *          把D:\\a.txt打包成一个压缩包         * */        //1.创建File对象表示要压缩的文件        File src = new File(&quot;D:\\a.txt&quot;);        //2.创建File对象表示压缩包的位置        File dest = new File(&quot;D:\\&quot;);        //3.调用方法用来压缩        toZip(src,dest);    &#125;    /*    *   作用：压缩    *   参数一：表示要压缩的文件    *   参数二：表示压缩包的位置    * */    public static void toZip(File src,File dest) throws IOException &#123;        //1.创建压缩流关联压缩包        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest,&quot;a.zip&quot;)));        //2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹        //参数：压缩包里面的路径        ZipEntry entry = new ZipEntry(&quot;aaa\\bbb\\a.txt&quot;);        //3.把ZipEntry对象放到压缩包当中        zos.putNextEntry(entry);        //4.把src文件中的数据写到压缩包当中        FileInputStream fis = new FileInputStream(src);        int b;        while((b = fis.read()) != -1)&#123;            zos.write(b);        &#125;        zos.closeEntry();        zos.close();    &#125;&#125;
public class ZipStreamDemo3 &#123;    public static void main(String[] args) throws IOException &#123;        /*         *   压缩流         *      需求：         *          把D:\\aaa文件夹压缩成一个压缩包         * */        //1.创建File对象表示要压缩的文件夹        File src = new File(&quot;D:\\aaa&quot;);        //2.创建File对象表示压缩包放在哪里（压缩包的父级路径）        File destParent = src.getParentFile();//D:\\        //3.创建File对象表示压缩包的路径        File dest = new File(destParent,src.getName() + &quot;.zip&quot;);        //4.创建压缩流关联压缩包        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest));        //5.获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中        toZip(src,zos,src.getName());//aaa        //6.释放资源        zos.close();    &#125;    /*    *   作用：获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中    *   参数一：数据源    *   参数二：压缩流    *   参数三：压缩包内部的路径    * */    public static void toZip(File src,ZipOutputStream zos,String name) throws IOException &#123;        //1.进入src文件夹        File[] files = src.listFiles();        //2.遍历数组        for (File file : files) &#123;            if(file.isFile())&#123;                //3.判断-文件，变成ZipEntry对象，放入到压缩包当中                ZipEntry entry = new ZipEntry(name + &quot;\\&quot; + file.getName());//aaa\\no1\\a.txt                zos.putNextEntry(entry);                //读取文件中的数据，写到压缩包                FileInputStream fis = new FileInputStream(file);                int b;                while((b = fis.read()) != -1)&#123;                    zos.write(b);                &#125;                fis.close();                zos.closeEntry();            &#125;else&#123;                //4.判断-文件夹，递归                toZip(file,zos,name + &quot;\\&quot; + file.getName());                //     no1            aaa   \\   no1            &#125;        &#125;    &#125;&#125;
6. 工具包（Commons-io）介绍：
​    Commons是apache开源基金组织提供的工具包，里面有很多帮助我们提高开发效率的API
比如：
​    StringUtils   字符串工具类
​    NumberUtils   数字工具类 
​    ArrayUtils   数组工具类  
​    RandomUtils   随机数工具类
​    DateUtils   日期工具类 
​    StopWatch   秒表工具类 
​    ClassUtils   反射工具类  
​    SystemUtils   系统工具类  
​    MapUtils   集合工具类
​    Beanutils   bean工具类
​    Commons-io io的工具类
​    等等…..
其中：Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。
作用：提高IO流的开发效率。
使用方式：
1，新建lib文件夹
2，把第三方jar包粘贴到文件夹中
3，右键点击add as a library
代码示例：
public class CommonsIODemo1 &#123;    public static void main(String[] args) throws IOException &#123;        /*          FileUtils类                static void copyFile(File srcFile, File destFile)                   复制文件                static void copyDirectory(File srcDir, File destDir)                复制文件夹                static void copyDirectoryToDirectory(File srcDir, File destDir)     复制文件夹                static void deleteDirectory(File directory)                         删除文件夹                static void cleanDirectory(File directory)                          清空文件夹                static String readFileToString(File file, Charset encoding)         读取文件中的数据变成成字符串                static void write(File file, CharSequence data, String encoding)    写出数据            IOUtils类                public static int copy(InputStream input, OutputStream output)      复制文件                public static int copyLarge(Reader input, Writer output)            复制大文件                public static String readLines(Reader input)                        读取数据                public static void write(String data, OutputStream output)          写出数据         */        /* File src = new File(&quot;myio\\a.txt&quot;);        File dest = new File(&quot;myio\\copy.txt&quot;);        FileUtils.copyFile(src,dest);*/        /*File src = new File(&quot;D:\\aaa&quot;);        File dest = new File(&quot;D:\\bbb&quot;);        FileUtils.copyDirectoryToDirectory(src,dest);*/        /*File src = new File(&quot;D:\\bbb&quot;);        FileUtils.cleanDirectory(src);*/    &#125;&#125;
7. 工具包（hutool）介绍：
​    Commons是国人开发的开源工具包，里面有很多帮助我们提高开发效率的API
比如：
​    DateUtil  日期时间工具类 
​    TimeInterval  计时器工具类 
​    StrUtil  字符串工具类
​    HexUtil   16进制工具类
​    HashUtil   Hash算法类
​    ObjectUtil  对象工具类
​    ReflectUtil   反射工具类
​    TypeUtil  泛型类型工具类
​    PageUtil  分页工具类
​    NumberUtil  数字工具类
使用方式：
1，新建lib文件夹
2，把第三方jar包粘贴到文件夹中
3，右键点击add as a library
代码示例：
public class Test1 &#123;    public static void main(String[] args) &#123;    /*        FileUtil类:                file：根据参数创建一个file对象                touch：根据参数创建文件                writeLines：把集合中的数据写出到文件中，覆盖模式。                appendLines：把集合中的数据写出到文件中，续写模式。                readLines：指定字符编码，把文件中的数据，读到集合中。                readUtf8Lines：按照UTF-8的形式，把文件中的数据，读到集合中                copy：拷贝文件或者文件夹    */       /* File file1 = FileUtil.file(&quot;D:\\&quot;, &quot;aaa&quot;, &quot;bbb&quot;, &quot;a.txt&quot;);        System.out.println(file1);//D:\aaa\bbb\a.txt        File touch = FileUtil.touch(file1);        System.out.println(touch);        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;aaa&quot;);        list.add(&quot;aaa&quot;);        list.add(&quot;aaa&quot;);        File file2 = FileUtil.writeLines(list, &quot;D:\\a.txt&quot;, &quot;UTF-8&quot;);        System.out.println(file2);*/      /*  ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;aaa&quot;);        list.add(&quot;aaa&quot;);        list.add(&quot;aaa&quot;);        File file3 = FileUtil.appendLines(list, &quot;D:\\a.txt&quot;, &quot;UTF-8&quot;);        System.out.println(file3);*/        List&lt;String&gt; list = FileUtil.readLines(&quot;D:\\a.txt&quot;, &quot;UTF-8&quot;);        System.out.println(list);    &#125;&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2025/04/11/JUC/</url>
    <content><![CDATA[1. 线程池1.1 线程状态介绍当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程
状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：
public class Thread &#123;        public enum State &#123;            /* 新建 */        NEW ,         /* 可运行状态 */        RUNNABLE ,         /* 阻塞状态 */        BLOCKED ,         /* 无限等待状态 */        WAITING ,         /* 计时等待 */        TIMED_WAITING ,         /* 终止 */        TERMINATED;    	&#125;        // 获取当前线程的状态    public State getState() &#123;        return jdk.internal.misc.VM.toThreadState(threadStatus);    &#125;    &#125;
通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下




线程状态
具体含义




NEW
一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。


RUNNABLE
当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。


BLOCKED
当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。


WAITING
一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。


TIMED_WAITING
一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。


TERMINATED
一个完全运行完成的线程的状态。也称之为终止状态、结束状态




各个状态的转换，如下图所示：

1.2 线程池-基本原理概述 : 
​    提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。
线程池存在的意义：
​    系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系
​    统资源的消耗，这样就有点”舍本逐末”了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就
​    会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。
线程池的设计思路 :

准备一个任务容器
一次性启动多个(2个)消费者线程
刚开始任务容器是空的，所以线程都在wait
直到一个外部线程向这个任务容器中扔了一个”任务”，就会有一个消费者线程被唤醒
这个消费者线程取出”任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来

1.3 线程池-Executors默认线程池概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。
我们可以使用Executors中所提供的静态方法来创建线程池
​    static ExecutorService newCachedThreadPool()   创建一个默认的线程池    static newFixedThreadPool(int nThreads)        创建一个指定最多线程数量的线程池
代码实现 : 
package com.itheima.mythreadpool;//static ExecutorService newCachedThreadPool()   创建一个默认的线程池//static newFixedThreadPool(int nThreads)	    创建一个指定最多线程数量的线程池import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class MyThreadPoolDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.        ExecutorService executorService = Executors.newCachedThreadPool();        //Executors --- 可以帮助我们创建线程池对象        //ExecutorService --- 可以帮助我们控制线程池        executorService.submit(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot;在执行了&quot;);        &#125;);        //Thread.sleep(2000);        executorService.submit(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot;在执行了&quot;);        &#125;);        executorService.shutdown();    &#125;&#125;
1.4 线程池-Executors创建指定上限的线程池使用Executors中所提供的静态方法来创建线程池
​    static ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池
代码实现 : 
package com.itheima.mythreadpool;//static ExecutorService newFixedThreadPool(int nThreads)//创建一个指定最多线程数量的线程池import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;public class MyThreadPoolDemo2 &#123;    public static void main(String[] args) &#123;        //参数不是初始值而是最大值        ExecutorService executorService = Executors.newFixedThreadPool(10);        ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService;        System.out.println(pool.getPoolSize());//0        executorService.submit(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot;在执行了&quot;);        &#125;);        executorService.submit(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot;在执行了&quot;);        &#125;);        System.out.println(pool.getPoolSize());//2//        executorService.shutdown();    &#125;&#125;
1.5 自定义线程池-ThreadPoolExecutor创建线程池对象 : 
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,时间单位,任务队列,创建线程工厂,任务的拒绝策略);
代码实现 : 
package com.itheima.mythreadpool;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class MyThreadPoolDemo3 &#123;//    参数一：核心线程数量//    参数二：最大线程数//    参数三：空闲线程最大存活时间//    参数四：时间单位//    参数五：任务队列//    参数六：创建线程工厂//    参数七：任务的拒绝策略    public static void main(String[] args) &#123;        ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());        pool.submit(new MyRunnable());        pool.submit(new MyRunnable());        pool.shutdown();    &#125;&#125;
1.6 线程池-参数详解
public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler)    corePoolSize：   核心线程的最大值，不能小于0maximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize &gt;= corePoolSizekeepAliveTime：  空闲线程最大存活时间,不能小于0unit：           时间单位workQueue：      任务队列，不能为nullthreadFactory：  创建线程工厂,不能为null      handler：        任务的拒绝策略,不能为null  
1.7 线程池-非默认任务拒绝策略RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。
ThreadPoolExecutor.AbortPolicy: 		    丢弃任务并抛出RejectedExecutionException异常。是默认的策略。ThreadPoolExecutor.DiscardPolicy： 		   丢弃任务，但是不抛出异常 这是不推荐的做法。ThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。ThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。
注：明确线程池对多可执行的任务数 = 队列容量 + 最大线程数
案例演示1：演示ThreadPoolExecutor.AbortPolicy任务处理策略
public class ThreadPoolExecutorDemo01 &#123;    public static void main(String[] args) &#123;        /**         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s         */        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,                new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ;        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常        for(int x = 0 ; x &lt; 5 ; x++) &#123;            threadPoolExecutor.submit(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + &quot;----&gt;&gt; 执行了任务&quot;);            &#125;);        &#125;    &#125;&#125;
控制台输出结果
pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务
控制台报错，仅仅执行了4个任务，有一个任务被丢弃了
案例演示2：演示ThreadPoolExecutor.DiscardPolicy任务处理策略
public class ThreadPoolExecutorDemo02 &#123;    public static void main(String[] args) &#123;        /**         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s         */        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,                new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ;        // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错        for(int x = 0 ; x &lt; 5 ; x++) &#123;            threadPoolExecutor.submit(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + &quot;----&gt;&gt; 执行了任务&quot;);            &#125;);        &#125;    &#125;&#125;
控制台输出结果
pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务
控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了
案例演示3：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略
public class ThreadPoolExecutorDemo02 &#123;    public static void main(String[] args) &#123;        /**         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s         */        ThreadPoolExecutor threadPoolExecutor;        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,                new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy());        // 提交5个任务        for(int x = 0 ; x &lt; 5 ; x++) &#123;            // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰            final int y = x ;            threadPoolExecutor.submit(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + &quot;----&gt;&gt; 执行了任务&quot; + y);            &#125;);             &#125;    &#125;&#125;
控制台输出结果
pool-1-thread-2----&gt;&gt; 执行了任务2pool-1-thread-1----&gt;&gt; 执行了任务0pool-1-thread-3----&gt;&gt; 执行了任务3pool-1-thread-1----&gt;&gt; 执行了任务4
由于任务1在线程池中等待时间最长，因此任务1被丢弃。
案例演示4：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略
public class ThreadPoolExecutorDemo04 &#123;    public static void main(String[] args) &#123;        /**         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s         */        ThreadPoolExecutor threadPoolExecutor;        threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS ,                new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy());        // 提交5个任务        for(int x = 0 ; x &lt; 5 ; x++) &#123;            threadPoolExecutor.submit(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + &quot;----&gt;&gt; 执行了任务&quot;);            &#125;);        &#125;    &#125;&#125;
控制台输出结果
pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务pool-1-thread-1----&gt;&gt; 执行了任务main----&gt;&gt; 执行了任务
通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。
1.8 线程池需要多大//获取最大并行数int i = Runtime.getRuntime().availableProcessors();System.out.println(i);
判断是cpu密集型（计算多）还是IO密集型（数据库操作多），分别计算线程池大小，cpu计算时间和等待时间可以通过thread dump工具测试

2. 多线程综合练习练习一：售票需求：
​    一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒,
​    请用多线程模拟卖票过程并打印剩余电影票的数量
代码示例：
public class MyThread extends Thread &#123;    //第一种方式实现多线程，测试类中MyThread会创建多次，所以需要加static    static int ticket = 1000;    @Override    public void run() &#123;        //1.循环        while (true) &#123;            //2.同步代码块            synchronized (MyThread.class) &#123;                //3.判断共享数据（已经到末尾）                if (ticket == 0) &#123;                    break;                &#125; else &#123;                    //4.判断共享数据（没有到末尾）                    try &#123;                        Thread.sleep(3000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    ticket--;                    System.out.println(getName() + &quot;在卖票，还剩下&quot; + ticket + &quot;张票!!!&quot;);                &#125;            &#125;        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;       /*            一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒,            要求:请用多线程模拟卖票过程并打印剩余电影票的数量        */        //创建线程对象        MyThread t1 = new MyThread();        MyThread t2 = new MyThread();        //给线程设置名字        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        //开启线程        t1.start();        t2.start();    &#125;&#125;
练习二：赠送礼物需求：
​    有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出。
​    利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来.
public class MyRunable implements Runnable &#123;    //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static    int count = 100;    @Override    public void run() &#123;        //1.循环        while (true) &#123;            //2.同步代码块            synchronized (MyThread.class) &#123;                //3.判断共享数据（已经到末尾）                if (count &lt; 10) &#123;                    System.out.println(&quot;礼物还剩下&quot; + count + &quot;不再赠送&quot;);                    break;                &#125; else &#123;                    //4.判断共享数据（没有到末尾）                    count--;                    System.out.println(Thread.currentThread().getName() + &quot;在赠送礼物，还剩下&quot; + count + &quot;个礼物!!!&quot;);                &#125;            &#125;        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        /*            有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出，            利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来.        */        //创建参数对象        MyRunable mr = new MyRunable();        //创建线程对象        Thread t1 = new Thread(mr,&quot;窗口1&quot;);        Thread t2 = new Thread(mr,&quot;窗口2&quot;);        //启动线程        t1.start();        t2.start();    &#125;&#125;
练习三：打印数字需求：
​    同时开启两个线程，共同获取1-100之间的所有数字。
​    将输出所有的奇数。
public class MyRunable implements Runnable &#123;    //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static    int number = 1;    @Override    public void run() &#123;        //1.循环        while (true) &#123;            //2.同步代码块            synchronized (MyThread.class) &#123;                //3.判断共享数据（已经到末尾）                if (number &gt; 100) &#123;                    break;                &#125; else &#123;                    //4.判断共享数据（没有到末尾）                    if(number % 2 == 1)&#123;                        System.out.println(Thread.currentThread().getName() + &quot;打印数字&quot; + number);                    &#125;                    number++;                &#125;            &#125;        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        /*           同时开启两个线程，共同获取1-100之间的所有数字。           要求：将输出所有的奇数。        */        //创建参数对象        MyRunable mr = new MyRunable();        //创建线程对象        Thread t1 = new Thread(mr,&quot;线程A&quot;);        Thread t2 = new Thread(mr,&quot;线程B&quot;);        //启动线程        t1.start();        t2.start();    &#125;&#125;
练习四：抢红包需求：
​    抢红包也用到了多线程。
​    假设：100块，分成了3个包，现在有5个人去抢。
​    其中，红包是共享数据。
​    5个人是5条线程。
​    打印结果如下：
​          XXX抢到了XXX元
​          XXX抢到了XXX元
      XXX抢到了XXX元

      XXX没抢到

      XXX没抢到
解决方案一：
public class MyThread extends Thread&#123;    //共享数据    //100块，分成了3个包    static double money = 100;    static int count = 3;    //最小的中奖金额    static final double MIN = 0.01;    @Override    public void run() &#123;        //同步代码块        synchronized (MyThread.class)&#123;            if(count == 0)&#123;                //判断，共享数据是否到了末尾（已经到末尾）                System.out.println(getName() + &quot;没有抢到红包！&quot;);            &#125;else&#123;                //判断，共享数据是否到了末尾（没有到末尾）                //定义一个变量，表示中奖的金额                double prize = 0;                if(count == 1)&#123;                    //表示此时是最后一个红包                    //就无需随机，剩余所有的钱都是中奖金额                    prize = money;                &#125;else&#123;                    //表示第一次，第二次（随机）                    Random r = new Random();                    //100 元   3个包                    //第一个红包：99.98                    //100 - (3-1) * 0.01                    double bounds = money - (count - 1) * MIN;                    prize = r.nextDouble(bounds);                    if(prize &lt; MIN)&#123;                        prize = MIN;                    &#125;                &#125;                //从money当中，去掉当前中奖的金额                money = money - prize;                //红包的个数-1                count--;                //本次红包的信息进行打印                System.out.println(getName() + &quot;抢到了&quot; + prize + &quot;元&quot;);            &#125;        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        /*            微信中的抢红包也用到了多线程。            假设：100块，分成了3个包，现在有5个人去抢。            其中，红包是共享数据。            5个人是5条线程。            打印结果如下：            	XXX抢到了XXX元            	XXX抢到了XXX元            	XXX抢到了XXX元            	XXX没抢到            	XXX没抢到        */        //创建线程的对象        MyThread t1 = new MyThread();        MyThread t2 = new MyThread();        MyThread t3 = new MyThread();        MyThread t4 = new MyThread();        MyThread t5 = new MyThread();        //给线程设置名字        t1.setName(&quot;小A&quot;);        t2.setName(&quot;小QQ&quot;);        t3.setName(&quot;小哈哈&quot;);        t4.setName(&quot;小诗诗&quot;);        t5.setName(&quot;小丹丹&quot;);        //启动线程        t1.start();        t2.start();        t3.start();        t4.start();        t5.start();    &#125;&#125;
解决方案二：
public class MyThread extends Thread&#123;    //总金额    static BigDecimal money = BigDecimal.valueOf(100.0);    //个数    static int count = 3;    //最小抽奖金额    static final BigDecimal MIN = BigDecimal.valueOf(0.01);    @Override    public void run() &#123;        synchronized (MyThread.class)&#123;            if(count == 0)&#123;                System.out.println(getName() + &quot;没有抢到红包！&quot;);            &#125;else&#123;                //中奖金额                BigDecimal prize;                if(count == 1)&#123;                    prize = money;                &#125;else&#123;                    //获取抽奖范围                    double bounds = money.subtract(BigDecimal.valueOf(count-1).multiply(MIN)).doubleValue();                    Random r = new Random();                    //抽奖金额                    prize = BigDecimal.valueOf(r.nextDouble(bounds));                &#125;                //设置抽中红包，小数点保留两位，四舍五入                prize = prize.setScale(2,RoundingMode.HALF_UP);                //在总金额中去掉对应的钱                money = money.subtract(prize);                //红包少了一个                count--;                //输出红包信息                System.out.println(getName() + &quot;抽中了&quot; + prize + &quot;元&quot;);            &#125;        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        /*            微信中的抢红包也用到了多线程。            假设：100块，分成了3个包，现在有5个人去抢。            其中，红包是共享数据。            5个人是5条线程。            打印结果如下：            	XXX抢到了XXX元            	XXX抢到了XXX元            	XXX抢到了XXX元            	XXX没抢到            	XXX没抢到        */        MyThread t1 = new MyThread();        MyThread t2 = new MyThread();        MyThread t3 = new MyThread();        MyThread t4 = new MyThread();        MyThread t5 = new MyThread();        t1.setName(&quot;小A&quot;);        t2.setName(&quot;小QQ&quot;);        t3.setName(&quot;小哈哈&quot;);        t4.setName(&quot;小诗诗&quot;);        t5.setName(&quot;小丹丹&quot;);        t1.start();        t2.start();        t3.start();        t4.start();        t5.start();    &#125;&#125;
练习五：抽奖箱需求：
​    有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700}; 
创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2” 
随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:
​               每次抽出一个奖项就打印一个(随机)
​        抽奖箱1 又产生了一个 10 元大奖
      抽奖箱1 又产生了一个 100 元大奖

      抽奖箱1 又产生了一个 200 元大奖

      抽奖箱1 又产生了一个 800 元大奖  
​        抽奖箱2 又产生了一个 700 元大奖  
      .....
public class MyThread extends Thread &#123;    ArrayList&lt;Integer&gt; list;    public MyThread(ArrayList&lt;Integer&gt; list) &#123;        this.list = list;    &#125;    @Override    public void run() &#123;        //1.循环        //2.同步代码块        //3.判断        //4.判断        while (true) &#123;            synchronized (MyThread.class) &#123;                if (list.size() == 0) &#123;                    break;                &#125; else &#123;                    //继续抽奖                    Collections.shuffle(list);                    int prize = list.remove(0);                    System.out.println(getName() + &quot;又产生了一个&quot; + prize + &quot;元大奖&quot;);                &#125;            &#125;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        /*            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;;            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:                             每次抽出一个奖项就打印一个(随机)            	抽奖箱1 又产生了一个 10 元大奖            	抽奖箱1 又产生了一个 100 元大奖            	抽奖箱1 又产生了一个 200 元大奖            	抽奖箱1 又产生了一个 800 元大奖            	抽奖箱2 又产生了一个 700 元大奖            	.....        */        //创建奖池        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);        //创建线程        MyThread t1 = new MyThread(list);        MyThread t2 = new MyThread(list);        //设置名字        t1.setName(&quot;抽奖箱1&quot;);        t2.setName(&quot;抽奖箱2&quot;);        //启动线程        t1.start();        t2.start();    &#125;&#125;
练习六：多线程统计并求最大值需求：
​    在上一题基础上继续完成如下需求：
​     每次抽的过程中，不打印，抽完时一次性打印(随机)
​     在此次抽奖过程中，抽奖箱1总共产生了6个奖项。
​              分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元
​     在此次抽奖过程中，抽奖箱2总共产生了6个奖项。
​              分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元
解决方案一：
public class MyThread extends Thread &#123;    ArrayList&lt;Integer&gt; list;    public MyThread(ArrayList&lt;Integer&gt; list) &#123;        this.list = list;    &#125;    //线程一    static ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();    //线程二    static ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();    @Override    public void run() &#123;        while (true) &#123;            synchronized (MyThread.class) &#123;                if (list.size() == 0) &#123;                    if(&quot;抽奖箱1&quot;.equals(getName()))&#123;                        System.out.println(&quot;抽奖箱1&quot; + list1);                    &#125;else &#123;                        System.out.println(&quot;抽奖箱2&quot; + list2);                    &#125;                    break;                &#125; else &#123;                    //继续抽奖                    Collections.shuffle(list);                    int prize = list.remove(0);                    if(&quot;抽奖箱1&quot;.equals(getName()))&#123;                        list1.add(prize);                    &#125;else &#123;                        list2.add(prize);                    &#125;                &#125;            &#125;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        /*            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;;            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元        */        //创建奖池        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);        //创建线程        MyThread t1 = new MyThread(list);        MyThread t2 = new MyThread(list);        //设置名字        t1.setName(&quot;抽奖箱1&quot;);        t2.setName(&quot;抽奖箱2&quot;);        //启动线程        t1.start();        t2.start();    &#125;&#125;
解决方案二：
public class MyThread extends Thread &#123;    ArrayList&lt;Integer&gt; list;    public MyThread(ArrayList&lt;Integer&gt; list) &#123;        this.list = list;    &#125;    @Override    public void run() &#123;        ArrayList&lt;Integer&gt; boxList = new ArrayList&lt;&gt;();//1 //2        while (true) &#123;            synchronized (MyThread.class) &#123;                if (list.size() == 0) &#123;                    System.out.println(getName() + boxList);                    break;                &#125; else &#123;                    //继续抽奖                    Collections.shuffle(list);                    int prize = list.remove(0);                    boxList.add(prize);                &#125;            &#125;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        /*            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;;            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元        */        //创建奖池        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);        //创建线程        MyThread t1 = new MyThread(list);        MyThread t2 = new MyThread(list);        //设置名字        t1.setName(&quot;抽奖箱1&quot;);        t2.setName(&quot;抽奖箱2&quot;);        //启动线程        t1.start();        t2.start();    &#125;&#125;
练习七：多线程之间的比较需求：
​    在上一题基础上继续完成如下需求：
​    在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300
  最高奖项为300元，总计额为932元
​    在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700
  最高奖项为800元，总计额为1835元
​    在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元
​    以上打印效果只是数据模拟,实际代码运行的效果会有差异
public class MyCallable implements Callable&lt;Integer&gt; &#123;    ArrayList&lt;Integer&gt; list;    public MyCallable(ArrayList&lt;Integer&gt; list) &#123;        this.list = list;    &#125;    @Override    public Integer call() throws Exception &#123;        ArrayList&lt;Integer&gt; boxList = new ArrayList&lt;&gt;();//1 //2        while (true) &#123;            synchronized (MyCallable.class) &#123;                if (list.size() == 0) &#123;                    System.out.println(Thread.currentThread().getName() + boxList);                    break;                &#125; else &#123;                    //继续抽奖                    Collections.shuffle(list);                    int prize = list.remove(0);                    boxList.add(prize);                &#125;            &#125;            Thread.sleep(10);        &#125;        //把集合中的最大值返回        if(boxList.size() == 0)&#123;            return null;        &#125;else&#123;            return Collections.max(boxList);        &#125;    &#125;&#125;package com.itheima.test7;import java.util.ArrayList;import java.util.Collections;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Test &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        /*            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;;            创建两个抽奖箱(线程)设置线程名称分别为    &quot;抽奖箱1&quot;, &quot;抽奖箱2&quot;            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:            在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300        	    最高奖项为300元，总计额为932元            在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700            	最高奖项为800元，总计额为1835元            在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元            核心逻辑：获取线程抽奖的最大值（看成是线程运行的结果）            以上打印效果只是数据模拟,实际代码运行的效果会有差异        */        //创建奖池        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700);        //创建多线程要运行的参数对象        MyCallable mc = new MyCallable(list);        //创建多线程运行结果的管理者对象        //线程一        FutureTask&lt;Integer&gt; ft1 = new FutureTask&lt;&gt;(mc);        //线程二        FutureTask&lt;Integer&gt; ft2 = new FutureTask&lt;&gt;(mc);        //创建线程对象        Thread t1 = new Thread(ft1);        Thread t2 = new Thread(ft2);        //设置名字        t1.setName(&quot;抽奖箱1&quot;);        t2.setName(&quot;抽奖箱2&quot;);        //开启线程        t1.start();        t2.start();        Integer max1 = ft1.get();        Integer max2 = ft2.get();        System.out.println(max1);        System.out.println(max2);        //在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元        if(max1 == null)&#123;            System.out.println(&quot;在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为&quot;+max2+&quot;元&quot;);        &#125;else if(max2 == null)&#123;            System.out.println(&quot;在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为&quot;+max1+&quot;元&quot;);        &#125;else if(max1 &gt; max2)&#123;            System.out.println(&quot;在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为&quot;+max1+&quot;元&quot;);        &#125;else if(max1 &lt; max2)&#123;            System.out.println(&quot;在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为&quot;+max2+&quot;元&quot;);        &#125;else&#123;            System.out.println(&quot;两者的最大奖项是一样的&quot;);        &#125;    &#125;&#125;
2. 原子性2.1 volatile-问题代码分析 : 
package com.itheima.myvolatile;public class Demo &#123;    public static void main(String[] args) &#123;        MyThread1 t1 = new MyThread1();        t1.setName(&quot;小路同学&quot;);        t1.start();        MyThread2 t2 = new MyThread2();        t2.setName(&quot;小皮同学&quot;);        t2.start();    &#125;&#125;
package com.itheima.myvolatile;public class Money &#123;    public static int money = 100000;&#125;
package com.itheima.myvolatile;public class MyThread1 extends  Thread &#123;    @Override    public void run() &#123;        while(Money.money == 100000)&#123;        &#125;        System.out.println(&quot;结婚基金已经不是十万了&quot;);    &#125;&#125;
package com.itheima.myvolatile;public class MyThread2 extends Thread &#123;    @Override    public void run() &#123;        try &#123;            Thread.sleep(10);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        Money.money = 90000;    &#125;&#125;
程序问题 :  女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。
2.2 volatile解决以上案例出现的问题 :
​    当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 
​    1，堆内存是唯一的，每一个线程都有自己的线程栈。
​    2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。
​    3 ，在线程中，每一次使用是从变量的副本中获取的。
Volatile关键字 : 强制线程每次在使用的时候，都会看一下共享区域最新的值
代码实现 : 使用volatile关键字解决
package com.itheima.myvolatile;public class Demo &#123;    public static void main(String[] args) &#123;        MyThread1 t1 = new MyThread1();        t1.setName(&quot;小路同学&quot;);        t1.start();        MyThread2 t2 = new MyThread2();        t2.setName(&quot;小皮同学&quot;);        t2.start();    &#125;&#125;
package com.itheima.myvolatile;public class Money &#123;    public static volatile int money = 100000;&#125;
package com.itheima.myvolatile;public class MyThread1 extends  Thread &#123;    @Override    public void run() &#123;        while(Money.money == 100000)&#123;        &#125;        System.out.println(&quot;结婚基金已经不是十万了&quot;);    &#125;&#125;
package com.itheima.myvolatile;public class MyThread2 extends Thread &#123;    @Override    public void run() &#123;        try &#123;            Thread.sleep(10);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        Money.money = 90000;    &#125;&#125;
2.3 synchronized解决synchronized解决 : 
​    1 ，线程获得锁
​    2 ，清空变量副本
​    3 ，拷贝共享变量最新的值到变量副本中
​    4 ，执行代码
​    5 ，将修改后变量副本中的值赋值给共享数据
​    6 ，释放锁
代码实现 : 
package com.itheima.myvolatile2;public class Demo &#123;    public static void main(String[] args) &#123;        MyThread1 t1 = new MyThread1();        t1.setName(&quot;小路同学&quot;);        t1.start();        MyThread2 t2 = new MyThread2();        t2.setName(&quot;小皮同学&quot;);        t2.start();    &#125;&#125;
package com.itheima.myvolatile2;public class Money &#123;    public static Object lock = new Object();    public static volatile int money = 100000;&#125;
package com.itheima.myvolatile2;public class MyThread1 extends  Thread &#123;    @Override    public void run() &#123;        while(true)&#123;            synchronized (Money.lock)&#123;                if(Money.money != 100000)&#123;                    System.out.println(&quot;结婚基金已经不是十万了&quot;);                    break;                &#125;            &#125;        &#125;    &#125;&#125;
package com.itheima.myvolatile2;public class MyThread2 extends Thread &#123;    @Override    public void run() &#123;        synchronized (Money.lock) &#123;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            Money.money = 90000;        &#125;    &#125;&#125;
2.4 原子性概述 : 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。
代码实现 : 
package com.itheima.threadatom;public class AtomDemo &#123;    public static void main(String[] args) &#123;        MyAtomThread atom = new MyAtomThread();        for (int i = 0; i &lt; 100; i++) &#123;            new Thread(atom).start();        &#125;    &#125;&#125;class MyAtomThread implements Runnable &#123;    private volatile int count = 0; //送冰淇淋的数量    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            //1,从共享数据中读取数据到本线程栈中.            //2,修改本线程栈中变量副本的值            //3,会把本线程栈中变量副本的值赋值给共享数据.            count++;            System.out.println(&quot;已经送了&quot; + count + &quot;个冰淇淋&quot;);        &#125;    &#125;&#125;
代码总结 : count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断
2.5 volatile关键字不能保证原子性解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。
package com.itheima.threadatom2;public class AtomDemo &#123;    public static void main(String[] args) &#123;        MyAtomThread atom = new MyAtomThread();        for (int i = 0; i &lt; 100; i++) &#123;            new Thread(atom).start();        &#125;    &#125;&#125;class MyAtomThread implements Runnable &#123;    private volatile int count = 0; //送冰淇淋的数量    private Object lock = new Object();    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            //1,从共享数据中读取数据到本线程栈中.            //2,修改本线程栈中变量副本的值            //3,会把本线程栈中变量副本的值赋值给共享数据.            synchronized (lock) &#123;                count++;                System.out.println(&quot;已经送了&quot; + count + &quot;个冰淇淋&quot;);            &#125;        &#125;    &#125;&#125;
2.6 原子性_AtomicInteger概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变
量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解
使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：
AtomicBoolean： 原子更新布尔类型
AtomicInteger：   原子更新整型
AtomicLong：    原子更新长整型
以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：
public AtomicInteger()：	   			    初始化一个默认值为0的原子型Integerpublic AtomicInteger(int initialValue)：  初始化一个指定值的原子型Integerint get():   			 				获取值int getAndIncrement():      			 以原子方式将当前值加1，注意，这里返回的是自增前的值。int incrementAndGet():     				 以原子方式将当前值加1，注意，这里返回的是自增后的值。int addAndGet(int data):				 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。int getAndSet(int value):   			 以原子方式设置为newValue的值，并返回旧值。
代码实现 :
package com.itheima.threadatom3;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomIntergerDemo1 &#123;//    public AtomicInteger()：	               初始化一个默认值为0的原子型Integer//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer    public static void main(String[] args) &#123;        AtomicInteger ac = new AtomicInteger();        System.out.println(ac);        AtomicInteger ac2 = new AtomicInteger(10);        System.out.println(ac2);    &#125;&#125;
package com.itheima.threadatom3;import java.lang.reflect.Field;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomIntergerDemo2 &#123;//    int get():   		 		获取值//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。//    int addAndGet(int data):	 以原子方式将参数与对象中的值相加，并返回结果。//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。    public static void main(String[] args) &#123;//        AtomicInteger ac1 = new AtomicInteger(10);//        System.out.println(ac1.get());//        AtomicInteger ac2 = new AtomicInteger(10);//        int andIncrement = ac2.getAndIncrement();//        System.out.println(andIncrement);//        System.out.println(ac2.get());//        AtomicInteger ac3 = new AtomicInteger(10);//        int i = ac3.incrementAndGet();//        System.out.println(i);//自增后的值//        System.out.println(ac3.get());//        AtomicInteger ac4 = new AtomicInteger(10);//        int i = ac4.addAndGet(20);//        System.out.println(i);//        System.out.println(ac4.get());        AtomicInteger ac5 = new AtomicInteger(100);        int andSet = ac5.getAndSet(20);        System.out.println(andSet);        System.out.println(ac5.get());    &#125;&#125;
2.7 AtomicInteger-内存解析AtomicInteger原理 : 自旋锁  + CAS 算法
CAS算法：
​    有3个操作数（内存值V， 旧的预期值A，要修改的值B）
​    当旧的预期值A == 内存值   此时修改成功，将V改为B                 
​    当旧的预期值A！=内存值   此时修改失败，不做任何操作                 
​    并重新获取现在的最新值（这个重新获取的动作就是自旋）
2.8 AtomicInteger-源码解析代码实现 :
package com.itheima.threadatom4;public class AtomDemo &#123;    public static void main(String[] args) &#123;        MyAtomThread atom = new MyAtomThread();        for (int i = 0; i &lt; 100; i++) &#123;            new Thread(atom).start();        &#125;    &#125;&#125;
package com.itheima.threadatom4;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomThread implements Runnable &#123;    //private volatile int count = 0; //送冰淇淋的数量    //private Object lock = new Object();    AtomicInteger ac = new AtomicInteger(0);    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            //1,从共享数据中读取数据到本线程栈中.            //2,修改本线程栈中变量副本的值            //3,会把本线程栈中变量副本的值赋值给共享数据.            //synchronized (lock) &#123;//                count++;//                ac++;            int count = ac.incrementAndGet();            System.out.println(&quot;已经送了&quot; + count + &quot;个冰淇淋&quot;);           // &#125;        &#125;    &#125;&#125;
源码解析 : 
//先自增，然后获取自增后的结果public final int incrementAndGet() &#123;        //+ 1 自增后的结果        //this 就表示当前的atomicInteger（值）        //1    自增一次        return U.getAndAddInt(this, VALUE, 1) + 1;&#125;public final int getAndAddInt(Object o, long offset, int delta) &#123;        //v 旧值        int v;        //自旋的过程        do &#123;            //不断的获取旧值            v = getIntVolatile(o, offset);            //如果这个方法的返回值为false，那么继续自旋            //如果这个方法的返回值为true，那么自旋结束            //o 表示的就是内存值            //v 旧值            //v + delta 修改后的值        &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta));            //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。            //                                 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。            //如果修改失败，那么继续自旋。        return v;&#125;
2.9 悲观锁和乐观锁synchronized和CAS的区别 : 
相同点：在多线程情况下，都可以保证共享数据的安全性。
不同点：synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每                       次操作共享数据之前，都会上锁。（悲观锁）
​    cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。
​    如果别人修改过，那么我再次获取现在最新的值。            
​     如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）
3. 并发工具类3.1 并发工具类-Hashtable​    Hashtable出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。
代码实现 : 
package com.itheima.mymap;import java.util.HashMap;import java.util.Hashtable;public class MyHashtableDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        Hashtable&lt;String, String&gt; hm = new Hashtable&lt;&gt;();        Thread t1 = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 25; i++) &#123;                hm.put(i + &quot;&quot;, i + &quot;&quot;);            &#125;        &#125;);        Thread t2 = new Thread(() -&gt; &#123;            for (int i = 25; i &lt; 51; i++) &#123;                hm.put(i + &quot;&quot;, i + &quot;&quot;);            &#125;        &#125;);        t1.start();        t2.start();        System.out.println(&quot;----------------------------&quot;);        //为了t1和t2能把数据全部添加完毕        Thread.sleep(1000);        //0-0 1-1 ..... 50- 50        for (int i = 0; i &lt; 51; i++) &#123;            System.out.println(hm.get(i + &quot;&quot;));        &#125;//0 1 2 3 .... 50    &#125;&#125;
3.2 并发工具类-ConcurrentHashMap基本使用​    ConcurrentHashMap出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。
基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。
体系结构 : 

总结 : 
​    1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题
​    2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下
​    3，ConcurrentHashMap也是线程安全的，效率较高。     在JDK7和JDK8中，底层原理不一样。
代码实现 : 
package com.itheima.mymap;import java.util.Hashtable;import java.util.concurrent.ConcurrentHashMap;public class MyConcurrentHashMapDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        ConcurrentHashMap&lt;String, String&gt; hm = new ConcurrentHashMap&lt;&gt;(100);        Thread t1 = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 25; i++) &#123;                hm.put(i + &quot;&quot;, i + &quot;&quot;);            &#125;        &#125;);        Thread t2 = new Thread(() -&gt; &#123;            for (int i = 25; i &lt; 51; i++) &#123;                hm.put(i + &quot;&quot;, i + &quot;&quot;);            &#125;        &#125;);        t1.start();        t2.start();        System.out.println(&quot;----------------------------&quot;);        //为了t1和t2能把数据全部添加完毕        Thread.sleep(1000);        //0-0 1-1 ..... 50- 50        for (int i = 0; i &lt; 51; i++) &#123;            System.out.println(hm.get(i + &quot;&quot;));        &#125;//0 1 2 3 .... 50    &#125;&#125;
3.3 并发工具类-ConcurrentHashMap1.7原理
3.4 并发工具类-ConcurrentHashMap1.8原理
总结 : 
​    1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。     在第一次添加元素的时候创建哈希表
​    2，计算当前元素应存入的索引。
​    3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。
​    4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。        
​    5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性
3.5 并发工具类-CountDownLatchCountDownLatch类 :         




方法
解释




public CountDownLatch(int count)
参数传递线程数，表示等待线程数量


public void await()
让线程等待


public void countDown()
当前线程执行完毕




使用场景： 让某一条线程等待其他线程执行完毕之后再执行
代码实现 : 
package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread1 extends Thread &#123;    private CountDownLatch countDownLatch;    public ChileThread1(CountDownLatch countDownLatch) &#123;        this.countDownLatch = countDownLatch;    &#125;    @Override    public void run() &#123;        //1.吃饺子        for (int i = 1; i &lt;= 10; i++) &#123;            System.out.println(getName() + &quot;在吃第&quot; + i + &quot;个饺子&quot;);        &#125;        //2.吃完说一声        //每一次countDown方法的时候，就让计数器-1        countDownLatch.countDown();    &#125;&#125;
package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread2 extends Thread &#123;    private CountDownLatch countDownLatch;    public ChileThread2(CountDownLatch countDownLatch) &#123;        this.countDownLatch = countDownLatch;    &#125;    @Override    public void run() &#123;        //1.吃饺子        for (int i = 1; i &lt;= 15; i++) &#123;            System.out.println(getName() + &quot;在吃第&quot; + i + &quot;个饺子&quot;);        &#125;        //2.吃完说一声        //每一次countDown方法的时候，就让计数器-1        countDownLatch.countDown();    &#125;&#125;
package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread3 extends Thread &#123;    private CountDownLatch countDownLatch;    public ChileThread3(CountDownLatch countDownLatch) &#123;        this.countDownLatch = countDownLatch;    &#125;    @Override    public void run() &#123;        //1.吃饺子        for (int i = 1; i &lt;= 20; i++) &#123;            System.out.println(getName() + &quot;在吃第&quot; + i + &quot;个饺子&quot;);        &#125;        //2.吃完说一声        //每一次countDown方法的时候，就让计数器-1        countDownLatch.countDown();    &#125;&#125;
package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class MotherThread extends Thread &#123;    private CountDownLatch countDownLatch;    public MotherThread(CountDownLatch countDownLatch) &#123;        this.countDownLatch = countDownLatch;    &#125;    @Override    public void run() &#123;        //1.等待        try &#123;            //当计数器变成0的时候，会自动唤醒这里等待的线程。            countDownLatch.await();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        //2.收拾碗筷        System.out.println(&quot;妈妈在收拾碗筷&quot;);    &#125;&#125;
package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class MyCountDownLatchDemo &#123;    public static void main(String[] args) &#123;        //1.创建CountDownLatch的对象，需要传递给四个线程。        //在底层就定义了一个计数器，此时计数器的值就是3        CountDownLatch countDownLatch = new CountDownLatch(3);        //2.创建四个线程对象并开启他们。        MotherThread motherThread = new MotherThread(countDownLatch);        motherThread.start();        ChileThread1 t1 = new ChileThread1(countDownLatch);        t1.setName(&quot;小明&quot;);        ChileThread2 t2 = new ChileThread2(countDownLatch);        t2.setName(&quot;小红&quot;);        ChileThread3 t3 = new ChileThread3(countDownLatch);        t3.setName(&quot;小刚&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;
总结 : 
​    1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。
​    2. await()：让线程等待，当计数器为0时，会唤醒等待的线程
​    3. countDown()： 线程执行完毕时调用，会将计数器-1。
3.6 并发工具类-Semaphore使用场景 : 
​    可以控制访问特定资源的线程数量。
实现步骤 : 
​    1，需要有人管理这个通道
​    2，当有车进来了，发通行许可证
​    3，当车出去了，收回通行许可证
​    4，如果通行许可证发完了，那么其他车辆只能等着
代码实现 : 
package com.itheima.mysemaphore;import java.util.concurrent.Semaphore;public class MyRunnable implements Runnable &#123;    //1.获得管理员对象，    private Semaphore semaphore = new Semaphore(2);    @Override    public void run() &#123;        //2.获得通行证        try &#123;            semaphore.acquire();            //3.开始行驶            System.out.println(&quot;获得了通行证开始行驶&quot;);            Thread.sleep(2000);            System.out.println(&quot;归还通行证&quot;);            //4.归还通行证            semaphore.release();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
package com.itheima.mysemaphore;public class MySemaphoreDemo &#123;    public static void main(String[] args) &#123;        MyRunnable mr = new MyRunnable();        for (int i = 0; i &lt; 100; i++) &#123;            new Thread(mr).start();        &#125;    &#125;&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2025/04/10/IO%E6%B5%81-%E5%AD%97%E8%8A%82%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
    <content><![CDATA[1. IO概述
1.1 什么是IO生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了ctrl+s ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。
我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。
Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。
1.2 IO的分类根据数据的流向分为：输入流和输出流。

输入流 ：把数据从其他设备上读取到内存中的流。 
输出流 ：把数据从内存 中写出到其他设备上的流。

格局数据的类型分为：字节流和字符流。

字节流 ：以字节为单位，读写数据的流。
字符流 ：以字符为单位，读写数据的流。

1.3 IO的流向说明图解
1.4 顶级父类们




输入流
输出流




字节流
字节输入流InputStream
字节输出流OutputStream


字符流
字符输入流Reader
字符输出流Writer




2. 字节流2.1 一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。
2.2 字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。

public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。  
public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。  
public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。  
public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  
public abstract void write(int b) ：将指定的字节输出流。


小贴士：
close方法，当完成流的操作时，必须调用此方法，释放系统资源。

2.3 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。
java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。
构造方法
public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 
public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。  

当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。

构造举例，代码如下：

public class FileOutputStreamConstructor throws IOException &#123;    public static void main(String[] args) &#123;   	 	// 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileOutputStream fos = new FileOutputStream(file);              // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;b.txt&quot;);    &#125;&#125;
写出字节数据
写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示：

public class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);           	// 写出数据      	fos.write(97); // 写出第1个字节      	fos.write(98); // 写出第2个字节      	fos.write(99); // 写出第3个字节      	// 关闭资源        fos.close();    &#125;&#125;输出结果：abc

小贴士：

虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。
流操作完毕后，必须释放系统资源，调用close方法，千万记得。



写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示：

public class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);           	// 字符串转换为字节数组      	byte[] b = &quot;黑马程序员&quot;.getBytes();      	// 写出字节数组数据      	fos.write(b);      	// 关闭资源        fos.close();    &#125;&#125;输出结果：黑马程序员

写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示：

public class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);           	// 字符串转换为字节数组      	byte[] b = &quot;abcde&quot;.getBytes();		// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。        fos.write(b,2,2);      	// 关闭资源        fos.close();    &#125;&#125;输出结果：cd
数据追加续写经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？

public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。  
public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。  

这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：
public class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;，true);           	// 字符串转换为字节数组      	byte[] b = &quot;abcde&quot;.getBytes();		// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。        fos.write(b);      	// 关闭资源        fos.close();    &#125;&#125;文件操作前：cd文件操作后：cdabcde
写出换行Windows系统里，换行符号是\r\n 。把
以指定是否追加续写了，代码使用演示：
public class FOSWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);        	// 定义字节数组      	byte[] words = &#123;97,98,99,100,101&#125;;      	// 遍历数组        for (int i = 0; i &lt; words.length; i++) &#123;          	// 写出一个字节            fos.write(words[i]);          	// 写出一个换行, 换行符号转成数组写出            fos.write(&quot;\r\n&quot;.getBytes());        &#125;      	// 关闭资源        fos.close();    &#125;&#125;输出结果：abcde


回车符\r和换行符\n ：
回车符：回到一行的开头（return）。
换行符：下一行（newline）。


系统中的换行：
Windows系统里，每行结尾是 回车+换行 ，即\r\n；
Unix系统里，每行结尾只有 换行 ，即\n；
Mac系统里，每行结尾是 回车 ，即\r。从 Mac OS X开始与Linux统一。




2.4 字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。

public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。    
public abstract int read()： 从输入流读取数据的下一个字节。 
public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。


小贴士：
close方法，当完成流的操作时，必须调用此方法，释放系统资源。

2.5 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。
构造方法
FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 
FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  

当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。

构造举例，代码如下：

public class FileInputStreamConstructor throws IOException&#123;    public static void main(String[] args) &#123;   	 	// 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileInputStream fos = new FileInputStream(file);              // 使用文件名称创建流对象        FileInputStream fos = new FileInputStream(&quot;b.txt&quot;);    &#125;&#125;
读取字节数据
读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示：

public class FISRead &#123;    public static void main(String[] args) throws IOException&#123;      	// 使用文件名称创建流对象       	FileInputStream fis = new FileInputStream(&quot;read.txt&quot;);      	// 读取数据，返回一个字节        int read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);        read = fis.read();        System.out.println((char) read);      	// 读取到末尾,返回-1       	read = fis.read();        System.out.println( read);		// 关闭资源        fis.close();    &#125;&#125;输出结果：abcde-1
循环改进读取方式，代码使用演示：
public class FISRead &#123;    public static void main(String[] args) throws IOException&#123;      	// 使用文件名称创建流对象       	FileInputStream fis = new FileInputStream(&quot;read.txt&quot;);      	// 定义变量，保存数据        int b ；        // 循环读取        while ((b = fis.read())!=-1) &#123;            System.out.println((char)b);        &#125;		// 关闭资源        fis.close();    &#125;&#125;输出结果：abcde

小贴士：

虽然读取了一个字节，但是会自动提升为int类型。
流操作完毕后，必须释放系统资源，调用close方法，千万记得。



使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示：

public class FISRead &#123;    public static void main(String[] args) throws IOException&#123;      	// 使用文件名称创建流对象.       	FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde      	// 定义变量，作为有效个数        int len ；        // 定义字节数组，作为装字节数据的容器           byte[] b = new byte[2];        // 循环读取        while (( len= fis.read(b))!=-1) &#123;           	// 每次读取后,把数组变成字符串打印            System.out.println(new String(b));        &#125;		// 关闭资源        fis.close();    &#125;&#125;输出结果：abcded
错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示：
public class FISRead &#123;    public static void main(String[] args) throws IOException&#123;      	// 使用文件名称创建流对象.       	FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde      	// 定义变量，作为有效个数        int len ；        // 定义字节数组，作为装字节数据的容器           byte[] b = new byte[2];        // 循环读取        while (( len= fis.read(b))!=-1) &#123;           	// 每次读取后,把数组的有效字节部分，变成字符串打印            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数        &#125;		// 关闭资源        fis.close();    &#125;&#125;输出结果：abcde

小贴士：
使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。

2.6 字节流练习：图片复制复制原理图解
案例实现复制图片文件，代码使用演示：
public class Copy &#123;    public static void main(String[] args) throws IOException &#123;        // 1.创建流对象        // 1.1 指定数据源        FileInputStream fis = new FileInputStream(&quot;D:\\test.jpg&quot;);        // 1.2 指定目的地        FileOutputStream fos = new FileOutputStream(&quot;test_copy.jpg&quot;);        // 2.读写数据        // 2.1 定义数组        byte[] b = new byte[1024];        // 2.2 定义长度        int len;        // 2.3 循环读取        while ((len = fis.read(b))!=-1) &#123;            // 2.4 写出数据            fos.write(b, 0 , len);        &#125;        // 3.关闭资源        fos.close();        fis.close();    &#125;&#125;

小贴士：
流的关闭原则：先开后关，后开先关。

3. 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。
3.1 字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。

public void close() ：关闭此流并释放与此流相关联的任何系统资源。    
public int read()： 从输入流读取一个字符。 
public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。

3.2 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。

小贴士：

字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。
idea中UTF-8

字节缓冲区：一个字节数组，用来临时存储字节数据。



构造方法
FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。   
FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。  

当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。

构造举例，代码如下：

public class FileReaderConstructor throws IOException&#123;    public static void main(String[] args) &#123;   	 	// 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileReader fr = new FileReader(file);              // 使用文件名称创建流对象        FileReader fr = new FileReader(&quot;b.txt&quot;);    &#125;&#125;
读取字符数据
读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示：

public class FRRead &#123;    public static void main(String[] args) throws IOException &#123;      	// 使用文件名称创建流对象       	FileReader fr = new FileReader(&quot;read.txt&quot;);      	// 定义变量，保存数据        int b ；        // 循环读取        while ((b = fr.read())!=-1) &#123;            System.out.println((char)b);        &#125;		// 关闭资源        fr.close();    &#125;&#125;输出结果：黑马程序员

小贴士：虽然读取了一个字符，但是会自动提升为int类型。


使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示：

public class FRRead &#123;    public static void main(String[] args) throws IOException &#123;      	// 使用文件名称创建流对象       	FileReader fr = new FileReader(&quot;read.txt&quot;);      	// 定义变量，保存有效字符个数        int len ；        // 定义字符数组，作为装字符数据的容器         char[] cbuf = new char[2];        // 循环读取        while ((len = fr.read(cbuf))!=-1) &#123;            System.out.println(new String(cbuf));        &#125;		// 关闭资源        fr.close();    &#125;&#125;输出结果：黑马程序员序
获取有效的字符改进，代码使用演示：
public class FISRead &#123;    public static void main(String[] args) throws IOException &#123;      	// 使用文件名称创建流对象       	FileReader fr = new FileReader(&quot;read.txt&quot;);      	// 定义变量，保存有效字符个数        int len ；        // 定义字符数组，作为装字符数据的容器        char[] cbuf = new char[2];        // 循环读取        while ((len = fr.read(cbuf))!=-1) &#123;            System.out.println(new String(cbuf,0,len));        &#125;    	// 关闭资源        fr.close();    &#125;&#125;输出结果：黑马程序员
3.3 字符输出流【Writer】java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。

void write(int c) 写入单个字符。
void write(char[] cbuf)写入字符数组。 
abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 
void write(String str)写入字符串。 
void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
void flush()刷新该流的缓冲。  
void close() 关闭此流，但要先刷新它。 

3.4 FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。
构造方法
FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。   
FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。  

当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。

构造举例，代码如下：

public class FileWriterConstructor &#123;    public static void main(String[] args) throws IOException &#123;   	 	// 使用File对象创建流对象        File file = new File(&quot;a.txt&quot;);        FileWriter fw = new FileWriter(file);              // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;b.txt&quot;);    &#125;&#125;
基本写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示：
public class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);           	// 写出数据      	fw.write(97); // 写出第1个字符      	fw.write(&#x27;b&#x27;); // 写出第2个字符      	fw.write(&#x27;C&#x27;); // 写出第3个字符      	fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。            	/*        【注意】关闭资源时,与FileOutputStream不同。      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。        */        // fw.close();    &#125;&#125;输出结果：abC田

小贴士：

虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。
未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。


关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。

flush ：刷新缓冲区，流对象可以继续使用。
close:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。

代码使用演示：
public class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);        // 写出数据，通过flush        fw.write(&#x27;刷&#x27;); // 写出第1个字符        fw.flush();        fw.write(&#x27;新&#x27;); // 继续写出第2个字符，写出成功        fw.flush();            	// 写出数据，通过close        fw.write(&#x27;关&#x27;); // 写出第1个字符        fw.close();        fw.write(&#x27;闭&#x27;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed        fw.close();    &#125;&#125;

小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。

写出其他数据
写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：

public class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);           	// 字符串转换为字节数组      	char[] chars = &quot;黑马程序员&quot;.toCharArray();            	// 写出字符数组      	fw.write(chars); // 黑马程序员        		// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。        fw.write(b,2,2); // 程序            	// 关闭资源        fos.close();    &#125;&#125;

写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示：

public class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);           	// 字符串      	String msg = &quot;黑马程序员&quot;;            	// 写出字符数组      	fw.write(msg); //黑马程序员      		// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。        fw.write(msg,2,2);	// 程序      	        // 关闭资源        fos.close();    &#125;&#125;

续写和换行：操作类似于FileOutputStream。

public class FWWrite &#123;    public static void main(String[] args) throws IOException &#123;        // 使用文件名称创建流对象，可以续写数据        FileWriter fw = new FileWriter(&quot;fw.txt&quot;，true);           	// 写出字符串        fw.write(&quot;黑马&quot;);      	// 写出换行      	fw.write(&quot;\r\n&quot;);      	// 写出字符串  		fw.write(&quot;程序员&quot;);      	// 关闭资源        fw.close();    &#125;&#125;输出结果:黑马程序员

小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。
当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流

4. IO异常的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，代码使用演示：
public class HandleException1 &#123;    public static void main(String[] args) &#123;      	// 声明变量        FileWriter fw = null;        try &#123;            //创建流对象            fw = new FileWriter(&quot;fw.txt&quot;);            // 写出数据            fw.write(&quot;黑马程序员&quot;); //黑马程序员        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if (fw != null) &#123;                    fw.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;
JDK7的处理(扩展知识点了解内容)还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。
格式：
try (创建流对象语句，如果多个,使用&#x27;;&#x27;隔开) &#123;	// 读写数据&#125; catch (IOException e) &#123;	e.printStackTrace();&#125;
代码使用演示：
public class HandleException2 &#123;    public static void main(String[] args) &#123;      	// 创建流对象        try ( FileWriter fw = new FileWriter(&quot;fw.txt&quot;); ) &#123;            // 写出数据            fw.write(&quot;黑马程序员&quot;); //黑马程序员        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
JDK9的改进(扩展知识点了解内容)JDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。
改进前格式：
// 被final修饰的对象final Resource resource1 = new Resource(&quot;resource1&quot;);// 普通对象Resource resource2 = new Resource(&quot;resource2&quot;);// 引入方式：创建新的变量保存try (Resource r1 = resource1;     Resource r2 = resource2) &#123;     // 使用对象&#125;
改进后格式：
// 被final修饰的对象final Resource resource1 = new Resource(&quot;resource1&quot;);// 普通对象Resource resource2 = new Resource(&quot;resource2&quot;);// 引入方式：直接引入try (resource1; resource2) &#123;     // 使用对象&#125;
改进后，代码使用演示：
public class TryDemo &#123;    public static void main(String[] args) throws IOException &#123;       	// 创建流对象        final  FileReader fr  = new FileReader(&quot;in.txt&quot;);        FileWriter fw = new FileWriter(&quot;out.txt&quot;);       	// 引入到try中        try (fr; fw) &#123;          	// 定义变量            int b;          	// 读取数据          	while ((b = fr.read())!=-1) &#123;            	// 写出数据            	fw.write(b);          	&#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;
5. 综合练习练习1：拷贝文件夹public class Test01 &#123;    public static void main(String[] args) throws IOException &#123;        //拷贝一个文件夹，考虑子文件夹        //1.创建对象表示数据源        File src = new File(&quot;D:\\aaa\\src&quot;);        //2.创建对象表示目的地        File dest = new File(&quot;D:\\aaa\\dest&quot;);        //3.调用方法开始拷贝        copydir(src,dest);    &#125;    /*    * 作用：拷贝文件夹    * 参数一：数据源    * 参数二：目的地    *    * */    private static void copydir(File src, File dest) throws IOException &#123;        dest.mkdirs();        //递归        //1.进入数据源        File[] files = src.listFiles();        //2.遍历数组        for (File file : files) &#123;            if(file.isFile())&#123;                //3.判断文件，拷贝                FileInputStream fis = new FileInputStream(file);                FileOutputStream fos = new FileOutputStream(new File(dest,file.getName()));                byte[] bytes = new byte[1024];                int len;                while((len = fis.read(bytes)) != -1)&#123;                    fos.write(bytes,0,len);                &#125;                fos.close();                fis.close();            &#125;else &#123;                //4.判断文件夹，递归                copydir(file, new File(dest,file.getName()));            &#125;        &#125;    &#125;&#125;
练习2：文件加密public class Test02 &#123;    public static void main(String[] args) throws IOException &#123;        /*            为了保证文件的安全性，就需要对原始文件进行加密存储，再使用的时候再对其进行解密处理。            加密原理：                对原始文件中的每一个字节数据进行更改，然后将更改以后的数据存储到新的文件中。            解密原理：                读取加密之后的文件，按照加密的规则反向操作，变成原始文件。             ^ : 异或                 两边相同：false                 两边不同：true                 0：false                 1：true               100:1100100               10: 1010               1100100             ^ 0001010             __________               1101110             ^ 0001010             __________               1100100        */    &#125;    public static void encryptionAndReduction(File src, File dest) throws IOException &#123;        FileInputStream fis = new FileInputStream(src);        FileOutputStream fos = new FileOutputStream(dest);        int b;        while ((b = fis.read()) != -1) &#123;            fos.write(b ^ 2);        &#125;        //4.释放资源        fos.close();        fis.close();    &#125;&#125;
练习3：数字排序文本文件中有以下的数据：                2-1-9-4-7-8 将文件中的数据进行排序，变成以下的数据：                1-2-4-7-8-9
实现方式一：
public class Test03 &#123;    public static void main(String[] args) throws IOException &#123;        /*            文本文件中有以下的数据：                2-1-9-4-7-8            将文件中的数据进行排序，变成以下的数据：                1-2-4-7-8-9        */        //1.读取数据        FileReader fr = new FileReader(&quot;myio\\a.txt&quot;);        StringBuilder sb = new StringBuilder();        int ch;        while((ch = fr.read()) != -1)&#123;            sb.append((char)ch);        &#125;        fr.close();        System.out.println(sb);        //2.排序        String str = sb.toString();        String[] arrStr = str.split(&quot;-&quot;);//2-1-9-4-7-8        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for (String s : arrStr) &#123;            int i = Integer.parseInt(s);            list.add(i);        &#125;        Collections.sort(list);        System.out.println(list);        //3.写出        FileWriter fw = new FileWriter(&quot;myio\\a.txt&quot;);        for (int i = 0; i &lt; list.size(); i++) &#123;            if(i == list.size() - 1)&#123;                fw.write(list.get(i) + &quot;&quot;);            &#125;else&#123;                fw.write(list.get(i) + &quot;-&quot;);            &#125;        &#125;        fw.close();    &#125;&#125;
实现方式二：
public class Test04 &#123;    public static void main(String[] args) throws IOException &#123;        /*            文本文件中有以下的数据：                2-1-9-4-7-8            将文件中的数据进行排序，变成以下的数据：                1-2-4-7-8-9           细节1：                文件中的数据不要换行            细节2:                bom头        */        //1.读取数据        FileReader fr = new FileReader(&quot;myio\\a.txt&quot;);        StringBuilder sb = new StringBuilder();        int ch;        while((ch = fr.read()) != -1)&#123;            sb.append((char)ch);        &#125;        fr.close();        System.out.println(sb);        //2.排序        Integer[] arr = Arrays.stream(sb.toString()                                      .split(&quot;-&quot;))            .map(Integer::parseInt)            .sorted()            .toArray(Integer[]::new);        //3.写出        FileWriter fw = new FileWriter(&quot;myio\\a.txt&quot;);        String s = Arrays.toString(arr).replace(&quot;, &quot;,&quot;-&quot;);        String result = s.substring(1, s.length() - 1);        fw.write(result);        fw.close();    &#125;&#125;
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis-Plus</title>
    <url>/2025/09/01/Mybatis-Plus/</url>
    <content><![CDATA[Mybatis-Plus
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot3</title>
    <url>/2025/09/01/SpringBoot3/</url>
    <content><![CDATA[SpringBoot3
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>MCP</title>
    <url>/2025/09/01/MCP/</url>
    <content><![CDATA[MCP
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCache</title>
    <url>/2025/09/01/SpringCache/</url>
    <content><![CDATA[SpringCache
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2025/09/01/SpringCloud/</url>
    <content><![CDATA[SpringCloud在线文档：https://b11et3un53m.feishu.cn/wiki/FJAnwOhpIihMkLkOKQocdWZ7nUchttps://b11et3un53m.feishu.cn/wiki/FJAnwOhpIihMkLkOKQocdWZ7nUc
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3</title>
    <url>/2025/09/01/Vue3/</url>
    <content><![CDATA[Vue3
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>八股</title>
    <url>/2025/09/01/%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[八股
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2025/04/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[1.实现多线程1.1简单了解多线程【理解】是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。

1.2并发和并行【理解】
并行：在同一时刻，有多个指令在多个CPU上同时执行。


并发：在同一时刻，有多个指令在单个CPU上交替执行。



1.3进程和线程【理解】
进程：是正在运行的程序
独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的并发性：任何进程都可以同其他进程一起并发执行

线程：是进程中的单个顺序控制流，是一条执行路径
​    单线程：一个进程如果只有一条执行路径，则称为单线程程序
​    多线程：一个进程如果有多条执行路径，则称为多线程程序
​    


1.4实现多线程方式一：继承Thread类【应用】

方法介绍
| 方法名          | 说明                         || —————— | ————————————— || void run()   | 在线程开启后，此方法将被调用执行           || void start() | 使此线程开始执行，Java虚拟机会调用run方法() |

实现步骤

定义一个类MyThread继承Thread类
在MyThread类中重写run()方法
创建MyThread类的对象
启动线程


代码演示
public class MyThread extends Thread &#123;    @Override    public void run() &#123;        for(int i=0; i&lt;100; i++) &#123;            System.out.println(i);        &#125;    &#125;&#125;public class MyThreadDemo &#123;    public static void main(String[] args) &#123;        MyThread my1 = new MyThread();        MyThread my2 = new MyThread();//        my1.run();//        my2.run();        //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法        my1.start();        my2.start();    &#125;&#125;

两个小问题

为什么要重写run()方法？
因为run()是用来封装被线程执行的代码

run()方法和start()方法的区别？
run()：封装线程执行的代码，直接调用，相当于普通方法的调用
start()：启动线程；然后由JVM调用此线程的run()方法




1.5实现多线程方式二：实现Runnable接口【应用】
Thread构造方法
| 方法名                                  | 说明             || —————————————————— | ——————— || Thread(Runnable target)              | 分配一个新的Thread对象 || Thread(Runnable target, String name) | 分配一个新的Thread对象 |

实现步骤

定义一个类MyRunnable实现Runnable接口
在MyRunnable类中重写run()方法
创建MyRunnable类的对象
创建Thread类的对象，把MyRunnable对象作为构造方法的参数
启动线程


代码演示
public class MyRunnable implements Runnable &#123;    @Override    public void run() &#123;        for(int i=0; i&lt;100; i++) &#123;            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);        &#125;    &#125;&#125;public class MyRunnableDemo &#123;    public static void main(String[] args) &#123;        //创建MyRunnable类的对象        MyRunnable my = new MyRunnable();        //创建Thread类的对象，把MyRunnable对象作为构造方法的参数        //Thread(Runnable target)//        Thread t1 = new Thread(my);//        Thread t2 = new Thread(my);        //Thread(Runnable target, String name)        Thread t1 = new Thread(my,&quot;坦克&quot;);        Thread t2 = new Thread(my,&quot;飞机&quot;);        //启动线程        t1.start();        t2.start();    &#125;&#125;


1.6实现多线程方式三: 实现Callable接口【应用】
方法介绍
| 方法名                              | 说明                                  || ———————————————— | —————————————————- || V call()                         | 计算结果，如果无法计算结果，则抛出一个异常               || FutureTask(Callable callable) | 创建一个 FutureTask，一旦运行就执行给定的 Callable || V get()                          | 如有必要，等待计算完成，然后获取其结果                 |

实现步骤

定义一个类MyCallable实现Callable接口
在MyCallable类中重写call()方法
创建MyCallable类的对象
创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数
创建Thread类的对象，把FutureTask对象作为构造方法的参数
启动线程
再调用get方法，就可以获取线程结束之后的结果。


代码演示
public class MyCallable implements Callable&lt;String&gt; &#123;    @Override    public String call() throws Exception &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(&quot;跟女孩表白&quot; + i);        &#125;        //返回值就表示线程运行完毕之后的结果        return &quot;答应&quot;;    &#125;&#125;public class Demo &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        //线程开启之后需要执行里面的call方法        MyCallable mc = new MyCallable();        //Thread t1 = new Thread(mc);        //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象        FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc);        //创建线程对象        Thread t1 = new Thread(ft);        String s = ft.get();        //开启线程        t1.start();        //String s = ft.get();        System.out.println(s);    &#125;&#125;

三种实现方式的对比

实现Runnable、Callable接口
好处: 扩展性强，实现该接口的同时还可以继承其他的类
缺点: 编程相对复杂，不能直接使用Thread类中的方法


继承Thread类
好处: 编程比较简单，可以直接使用Thread类中的方法
缺点: 可以扩展性较差，不能再继承其他的类





1.7设置和获取线程名称【应用】
方法介绍
| 方法名                     | 说明                                                         || ————————————— | —————————————————————————————— || void  setName(String name) | 将此线程的名称更改为等于参数name                             || String  getName()          | 返回此线程的名称，如果没有给线程设置名字，线程默认的名宇格式：Thread-X(X序号，从0开始的) || Thread  currentThread()    | 返回对当前正在执行的线程对象的引用                           |

代码演示
public class MyThread extends Thread &#123;    public MyThread() &#123;&#125;    public MyThread(String name) &#123;        super(name);    &#125;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(getName()+&quot;:&quot;+i);        &#125;    &#125;&#125;public class MyThreadDemo &#123;    public static void main(String[] args) &#123;        MyThread my1 = new MyThread();        MyThread my2 = new MyThread();        //void setName(String name)：将此线程的名称更改为等于参数 name        my1.setName(&quot;高铁&quot;);        my2.setName(&quot;飞机&quot;);        //Thread(String name)        MyThread my1 = new MyThread(&quot;高铁&quot;);        MyThread my2 = new MyThread(&quot;飞机&quot;);        my1.start();        my2.start();        //static Thread currentThread() 返回对当前正在执行的线程对象的引用        System.out.println(Thread.currentThread().getName());    &#125;&#125;


当JVM虚拟机启动之后，会自动的启动多条线程，其中有一条线程就叫做main线程，他的作用就是去调用main方法，并执行里面的代码，在以前，我们写的所有的代码，其实都是运行在main线程当中。
1.8线程休眠【应用】
相关方法
| 方法名                            | 说明                       || ——————————————— | ———————————— || static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数 |

代码演示
public class MyRunnable implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + &quot;---&quot; + i);        &#125;    &#125;&#125;public class Demo &#123;    public static void main(String[] args) throws InterruptedException &#123;        /*System.out.println(&quot;睡觉前&quot;);        Thread.sleep(3000);        System.out.println(&quot;睡醒了&quot;);*/        MyRunnable mr = new MyRunnable();        Thread t1 = new Thread(mr);        Thread t2 = new Thread(mr);        t1.start();        t2.start();    &#125;&#125;


1.9线程优先级【应用】线程优先级越高，抢到CPU使用权的概率越大，而不是100%能抢到

线程调度

两种调度方式

分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些


Java使用的是抢占式调度模型

随机性（抢占式调度模型）
假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的




优先级相关方法
| 方法名                                  | 说明                                                         || ———————————————————- | —————————————————————————————— || final int getPriority()                 | 返回此线程的优先级                                           || final void setPriority(int newPriority) | 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 |

代码演示
public class MyCallable implements Callable&lt;String&gt; &#123;    @Override    public String call() throws Exception &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(Thread.currentThread().getName() + &quot;---&quot; + i);        &#125;        return &quot;线程执行完毕了&quot;;    &#125;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        //优先级: 1 - 10 默认值:5        MyCallable mc = new MyCallable();        FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc);        Thread t1 = new Thread(ft);        t1.setName(&quot;飞机&quot;);        t1.setPriority(10);        //System.out.println(t1.getPriority());//5        t1.start();        MyCallable mc2 = new MyCallable();        FutureTask&lt;String&gt; ft2 = new FutureTask&lt;&gt;(mc2);        Thread t2 = new Thread(ft2);        t2.setName(&quot;坦克&quot;);        t2.setPriority(1);        //System.out.println(t2.getPriority());//5        t2.start();    &#125;&#125;


1.10守护线程【应用】当其他的非守护线程执行完毕之后，守护线程会陆续结束


相关方法
| 方法名                        | 说明                                   || ————————————— | —————————————————— || void setDaemon(boolean on) | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |

代码演示
public class MyThread1 extends Thread &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(getName() + &quot;---&quot; + i);        &#125;    &#125;&#125;public class MyThread2 extends Thread &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(getName() + &quot;---&quot; + i);        &#125;    &#125;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        MyThread1 t1 = new MyThread1();        MyThread2 t2 = new MyThread2();        t1.setName(&quot;女神&quot;);        t2.setName(&quot;备胎&quot;);        //把第二个线程设置为守护线程        //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.        t2.setDaemon(true);        t1.start();        t2.start();    &#125;&#125;


1.11出让线程/礼让线程public static void yield()
尽可能让执行的多个线程均匀地执行，让礼让线程执行完之后，会让出cpu的使用权，再重新跟其他线程抢夺cpu。
1.12插入线程/插队线程public final void join()
表示把该线程插入到当前线程之前。该线程全部执行完了才执行当前线程。
2.线程同步2.1卖票【应用】
案例需求
某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票

实现步骤

定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100;

在SellTicket类中重写run()方法实现卖票，代码步骤如下

判断票数大于0，就卖票，并告知是哪个窗口卖的

卖了票之后，总票数要减1
票卖没了，线程停止
定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下
创建SellTicket类的对象
创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称
启动线程


代码实现
public class SellTicket implements Runnable &#123;    private int tickets = 100;    //在SellTicket类中重写run()方法实现卖票，代码步骤如下    @Override    public void run() &#123;        while (true) &#123;            if(ticket &lt;= 0)&#123;                    //卖完了                    break;                &#125;else&#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    ticket--;                    System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticket + &quot;张票&quot;);                &#125;        &#125;    &#125;&#125;public class SellTicketDemo &#123;    public static void main(String[] args) &#123;        //创建SellTicket类的对象        SellTicket st = new SellTicket();        //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称        Thread t1 = new Thread(st,&quot;窗口1&quot;);        Thread t2 = new Thread(st,&quot;窗口2&quot;);        Thread t3 = new Thread(st,&quot;窗口3&quot;);        //启动线程        t1.start();        t2.start();        t3.start();    &#125;&#125;


2.2卖票案例的问题【理解】
卖票出现了问题

相同的票出现了多次

出现了负数的票/超卖



问题产生原因
线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题


2.3同步代码块解决数据安全问题【应用】
安全问题出现的条件

是多线程环境

有共享数据

有多条语句操作共享数据



如何解决多线程安全问题呢?

基本思想：让程序没有安全问题的环境


怎么实现呢?

把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可

Java提供了同步代码块的方式来解决



同步代码块格式：
synchronized(任意对象) &#123; 	多条语句操作共享数据的代码 &#125;
synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁
锁对象可以是任意对象：static Object obj=new Object( );
但是锁对象一般用的是当前类的字节码文件

同步的好处和弊端  

好处：解决了多线程的数据安全问题

弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率



代码演示
public class SellTicket implements Runnable &#123;    private int tickets = 100;    private Object obj = new Object();    @Override    public void run() &#123;        while (true) &#123;            synchronized (obj) &#123; // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁                //t1进来后，就会把这段代码给锁起来                if (tickets &gt; 0) &#123;                    try &#123;                        Thread.sleep(100);                        //t1休息100毫秒                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    //窗口1正在出售第100张票                    System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;);                    tickets--; //tickets = 99;                &#125;            &#125;            //t1出来了，这段代码的锁就被释放了        &#125;    &#125;&#125;public class SellTicketDemo &#123;    public static void main(String[] args) &#123;        SellTicket st = new SellTicket();        Thread t1 = new Thread(st, &quot;窗口1&quot;);        Thread t2 = new Thread(st, &quot;窗口2&quot;);        Thread t3 = new Thread(st, &quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;


2.4同步方法解决数据安全问题【应用】
同步方法的格式
同步方法：就是把synchronized关键字加到方法上
修饰符 synchronized 返回值类型 方法名(方法参数) &#123; 	方法体；&#125;
同步方法的锁对象是什么呢?
​    this

静态同步方法
同步静态方法：就是把synchronized关键字加到静态方法上
修饰符 static synchronized 返回值类型 方法名(方法参数) &#123; 	方法体；&#125;
同步静态方法的锁对象是什么呢?
​    类名.class

代码演示
 选中synchronized同步代码块里的代码ctrl+alt+M抽取成方法，再删除synchronized同步代码块，在方法前加synchronized
public class MyRunnable implements Runnable &#123;    private static int ticketCount = 100;    @Override    public void run() &#123;        while(true)&#123;            if(&quot;窗口一&quot;.equals(Thread.currentThread().getName()))&#123;                //同步方法                boolean result = synchronizedMthod();                if(result)&#123;                    break;                &#125;            &#125;            if(&quot;窗口二&quot;.equals(Thread.currentThread().getName()))&#123;                //同步代码块                synchronized (MyRunnable.class)&#123;                    if(ticketCount == 0)&#123;                       break;                    &#125;else&#123;                        try &#123;                            Thread.sleep(10);                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                        ticketCount--;                        System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticketCount + &quot;张票&quot;);                    &#125;                &#125;            &#125;        &#125;    &#125;    private static synchronized boolean synchronizedMthod() &#123;        if(ticketCount == 0)&#123;            return true;        &#125;else&#123;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            ticketCount--;            System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticketCount + &quot;张票&quot;);            return false;        &#125;    &#125;&#125;


  public class Demo {      public static void main(String[] args) {          MyRunnable mr = new MyRunnable();
      Thread t1 = new Thread(mr);
      Thread t2 = new Thread(mr);

      t1.setName(&quot;窗口一&quot;);
      t2.setName(&quot;窗口二&quot;);

      t1.start();
      t2.start();
  &#125;
  }
2.5Lock锁【应用】虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock
Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化

ReentrantLock构造方法
| 方法名          | 说明                        || ———————- | —————————————- || ReentrantLock() | 创建一个ReentrantLock的实例 |

加锁解锁方法
| 方法名        | 说明   || ——————- | ——— || void lock()   | 获得锁 || void unlock() | 释放锁 |

代码演示
public class Ticket implements Runnable &#123;    //票的数量    private int ticket = 100;    private Object obj = new Object();    private ReentrantLock lock = new ReentrantLock();    @Override    public void run() &#123;        while (true) &#123;            //synchronized (obj)&#123;//多个线程必须使用同一把锁.            try &#123;                lock.lock();                if (ticket &lt;= 0) &#123;                    //卖完了                    break;                &#125; else &#123;                    Thread.sleep(100);                    ticket--;                    System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticket + &quot;张票&quot;);                &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                lock.unlock();            &#125;            // &#125;        &#125;    &#125;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        Ticket ticket = new Ticket();        Thread t1 = new Thread(ticket);        Thread t2 = new Thread(ticket);        Thread t3 = new Thread(ticket);        t1.setName(&quot;窗口一&quot;);        t2.setName(&quot;窗口二&quot;);        t3.setName(&quot;窗口三&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;


2.6死锁【理解】
概述
线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行

什么情况下会产生死锁

资源有限
同步嵌套


代码演示
public class Demo &#123;    public static void main(String[] args) &#123;        Object objA = new Object();        Object objB = new Object();        new Thread(()-&gt;&#123;            while(true)&#123;                synchronized (objA)&#123;                    //线程一                    synchronized (objB)&#123;                        System.out.println(&quot;小康同学正在走路&quot;);                    &#125;                &#125;            &#125;        &#125;).start();        new Thread(()-&gt;&#123;            while(true)&#123;                synchronized (objB)&#123;                    //线程二                    synchronized (objA)&#123;                        System.out.println(&quot;小薇同学正在走路&quot;);                    &#125;                &#125;            &#125;        &#125;).start();    &#125;&#125;


3.生产者消费者3.1生产者和消费者模式概述【应用】
概述
生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。
所谓生产者消费者问题，实际上主要是包含了两类线程：
​    一类是生产者线程用于生产数据
​    一类是消费者线程用于消费数据
为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库
生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为
消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为

Object类的等待和唤醒方法
| 方法名              | 说明                                       || ———————— | ———————————————————— || void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 || void notify()    | 唤醒正在等待对象监视器的单个线程                         || void notifyAll() | 唤醒正在等待对象监视器的所有线程                         |


3.2生产者和消费者案例【应用】
案例需求

桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量

生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务
  1.判断是否有包子,决定当前线程是否执行
  2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子
  3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子

消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务
  1.判断是否有包子,决定当前线程是否执行
  2.如果没有包子,就进入等待状态,如果有包子,就消费包子
  3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子

测试类(Demo)：里面有main方法，main方法中的代码步骤如下
  创建生产者线程和消费者线程对象
  分别开启两个线程



代码实现
public class Desk &#123;    //定义一个标记    //true 就表示桌子上有汉堡包的,此时允许吃货执行    //false 就表示桌子上没有汉堡包的,此时允许厨师执行    public static boolean flag = false;    //汉堡包的总数量    public static int count = 10;    //锁对象    public static final Object lock = new Object();&#125;public class Cooker extends Thread &#123;//    生产者步骤：//            1，判断桌子上是否有汉堡包//    如果有就等待，如果没有才生产。//            2，把汉堡包放在桌子上。//            3，叫醒等待的消费者开吃。    @Override    public void run() &#123;        while(true)&#123;            synchronized (Desk.lock)&#123;                if(Desk.count == 0)&#123;                    break;                &#125;else&#123;                    if(!Desk.flag)&#123;                        //生产                        System.out.println(&quot;厨师正在生产汉堡包&quot;);                        Desk.flag = true;                        Desk.lock.notifyAll();                    &#125;else&#123;                        try &#123;                            Desk.lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;public class Foodie extends Thread &#123;    @Override    public void run() &#123;//        1，判断桌子上是否有汉堡包。//        2，如果没有就等待。//        3，如果有就开吃//        4，吃完之后，桌子上的汉堡包就没有了//                叫醒等待的生产者继续生产//        汉堡包的总数量减一        //套路:            //1. while(true)死循环            //2. synchronized 锁,锁对象要唯一            //3. 判断,共享数据是否结束. 结束            //4. 判断,共享数据是否结束. 没有结束        while(true)&#123;            synchronized (Desk.lock)&#123;                if(Desk.count == 0)&#123;                    break;                &#125;else&#123;                    if(Desk.flag)&#123;                        //有                        System.out.println(&quot;吃货在吃汉堡包&quot;);                        Desk.flag = false;                        Desk.lock.notifyAll();                        Desk.count--;                    &#125;else&#123;                        //没有就等待                        //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.                        try &#123;                            Desk.lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        /*消费者步骤：        1，判断桌子上是否有汉堡包。        2，如果没有就等待。        3，如果有就开吃        4，吃完之后，桌子上的汉堡包就没有了                叫醒等待的生产者继续生产        汉堡包的总数量减一*/        /*生产者步骤：        1，判断桌子上是否有汉堡包        如果有就等待，如果没有才生产。        2，把汉堡包放在桌子上。        3，叫醒等待的消费者开吃。*/        Foodie f = new Foodie();        Cooker c = new Cooker();        f.start();        c.start();    &#125;&#125;


3.3生产者和消费者案例优化【应用】
需求

将Desk类中的变量,采用面向对象的方式封装起来
生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用
创建生产者和消费者线程对象,构造方法中传入Desk类对象
开启两个线程


代码实现
public class Desk &#123;    //定义一个标记    //true 就表示桌子上有汉堡包的,此时允许吃货执行    //false 就表示桌子上没有汉堡包的,此时允许厨师执行    //public static boolean flag = false;    private boolean flag;    //汉堡包的总数量    //public static int count = 10;    //以后我们在使用这种必须有默认值的变量   // private int count = 10;    private int count;    //锁对象    //public static final Object lock = new Object();    private final Object lock = new Object();    public Desk() &#123;        this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了    &#125;    public Desk(boolean flag, int count) &#123;        this.flag = flag;        this.count = count;    &#125;    public boolean isFlag() &#123;        return flag;    &#125;    public void setFlag(boolean flag) &#123;        this.flag = flag;    &#125;    public int getCount() &#123;        return count;    &#125;    public void setCount(int count) &#123;        this.count = count;    &#125;    public Object getLock() &#123;        return lock;    &#125;    @Override    public String toString() &#123;        return &quot;Desk&#123;&quot; +                &quot;flag=&quot; + flag +                &quot;, count=&quot; + count +                &quot;, lock=&quot; + lock +                &#x27;&#125;&#x27;;    &#125;&#125;public class Cooker extends Thread &#123;    private Desk desk;    public Cooker(Desk desk) &#123;        this.desk = desk;    &#125;//    生产者步骤：//            1，判断桌子上是否有汉堡包//    如果有就等待，如果没有才生产。//            2，把汉堡包放在桌子上。//            3，叫醒等待的消费者开吃。    @Override    public void run() &#123;        while(true)&#123;            synchronized (desk.getLock())&#123;                if(desk.getCount() == 0)&#123;                    break;                &#125;else&#123;                    //System.out.println(&quot;验证一下是否执行了&quot;);                    if(!desk.isFlag())&#123;                        //生产                        System.out.println(&quot;厨师正在生产汉堡包&quot;);                        desk.setFlag(true);                        desk.getLock().notifyAll();                    &#125;else&#123;                        try &#123;                            desk.getLock().wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;public class Foodie extends Thread &#123;    private Desk desk;    public Foodie(Desk desk) &#123;        this.desk = desk;    &#125;    @Override    public void run() &#123;//        1，判断桌子上是否有汉堡包。//        2，如果没有就等待。//        3，如果有就开吃//        4，吃完之后，桌子上的汉堡包就没有了//                叫醒等待的生产者继续生产//        汉堡包的总数量减一        //套路:            //1. while(true)死循环            //2. synchronized 锁,锁对象要唯一            //3. 判断,共享数据是否结束. 结束            //4. 判断,共享数据是否结束. 没有结束        while(true)&#123;            synchronized (desk.getLock())&#123;                if(desk.getCount() == 0)&#123;                    break;                &#125;else&#123;                    //System.out.println(&quot;验证一下是否执行了&quot;);                    if(desk.isFlag())&#123;                        //有                        System.out.println(&quot;吃货在吃汉堡包&quot;);                        desk.setFlag(false);                        desk.getLock().notifyAll();                        desk.setCount(desk.getCount() - 1);                    &#125;else&#123;                        //没有就等待                        //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.                        try &#123;                            desk.getLock().wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        /*消费者步骤：        1，判断桌子上是否有汉堡包。        2，如果没有就等待。        3，如果有就开吃        4，吃完之后，桌子上的汉堡包就没有了                叫醒等待的生产者继续生产        汉堡包的总数量减一*/        /*生产者步骤：        1，判断桌子上是否有汉堡包        如果有就等待，如果没有才生产。        2，把汉堡包放在桌子上。        3，叫醒等待的消费者开吃。*/        Desk desk = new Desk();        Foodie f = new Foodie(desk);        Cooker c = new Cooker(desk);        f.start();        c.start();    &#125;&#125;


3.4阻塞队列基本使用【理解】
阻塞队列继承结构




常见BlockingQueue:
 ArrayBlockingQueue: 底层是数组,有界
 LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值

BlockingQueue的核心方法:
 put(anObject): 将参数放入队列,如果放不进去会阻塞
 take(): 取出第一个数据,取不到会阻塞

代码示例
public class Demo02 &#123;    public static void main(String[] args) throws Exception &#123;        // 创建阻塞队列的对象,容量为 1        ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(1);        // 存储元素        arrayBlockingQueue.put(&quot;汉堡包&quot;);        // 取元素        System.out.println(arrayBlockingQueue.take());        System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞        System.out.println(&quot;程序结束了&quot;);    &#125;&#125;


3.5阻塞队列实现等待唤醒机制【理解】
案例需求

生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务
  1.构造方法中接收一个阻塞队列对象
  2.在run方法中循环向阻塞队列中添加包子
  3.打印添加结果

消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务
   1.构造方法中接收一个阻塞队列对象
   2.在run方法中循环获取阻塞队列中的包子
   3.打印获取结果

测试类(Demo)：里面有main方法，main方法中的代码步骤如下
  创建阻塞队列对象
  创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象
  分别开启两个线程



代码实现
public class Cooker extends Thread &#123;    private ArrayBlockingQueue&lt;String&gt; bd;    public Cooker(ArrayBlockingQueue&lt;String&gt; bd) &#123;        this.bd = bd;    &#125;//    生产者步骤：//            1，判断桌子上是否有汉堡包//    如果有就等待，如果没有才生产。//            2，把汉堡包放在桌子上。//            3，叫醒等待的消费者开吃。    @Override    public void run() &#123;        while (true) &#123;            try &#123;                bd.put(&quot;汉堡包&quot;);                System.out.println(&quot;厨师放入一个汉堡包&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;public class Foodie extends Thread &#123;    private ArrayBlockingQueue&lt;String&gt; bd;    public Foodie(ArrayBlockingQueue&lt;String&gt; bd) &#123;        this.bd = bd;    &#125;    @Override    public void run() &#123;//        1，判断桌子上是否有汉堡包。//        2，如果没有就等待。//        3，如果有就开吃//        4，吃完之后，桌子上的汉堡包就没有了//                叫醒等待的生产者继续生产//        汉堡包的总数量减一        //套路:        //1. while(true)死循环        //2. synchronized 锁,锁对象要唯一        //3. 判断,共享数据是否结束. 结束        //4. 判断,共享数据是否结束. 没有结束        while (true) &#123;            try &#123;                String take = bd.take();                System.out.println(&quot;吃货将&quot; + take + &quot;拿出来吃了&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;public class Demo &#123;    public static void main(String[] args) &#123;        ArrayBlockingQueue&lt;String&gt; bd = new ArrayBlockingQueue&lt;&gt;(1);        Foodie f = new Foodie(bd);        Cooker c = new Cooker(bd);        f.start();        c.start();    &#125;&#125;


4.线程的生命周期
5.线程的状态
6种状态，没有运行状态



6.多线程的书写套路1.循环2.同步代码块3.判断共享数据是否到了末尾（到了末尾）4,判断共享数据是否到了末尾（没有到末尾，执行核心逻辑）
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>大模型开发</title>
    <url>/2025/09/01/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[在线文档：https://b11et3un53m.feishu.cn/wiki/DESQw9K4ji6Nf4kd9fzcwJTunmb
AI发展

符号主义
机器学习
深度学习 -&gt; 自然语言处理(NLP) -&gt; 大语言模型(LLM)大语言模型**Transformer**
在**自然语言处理**(Natural Language Processing,**NLP**)中，有一项关键技术叫**Transformer**,这是一种先进的深度学习的**神经网络模型**，是现如今AI高速发展的最主要原因。我们所熟知的**大模型**(Large Language Models,LLM),例如**GPT**、**DeepSeek**)底层都是采用Transformer神经网络模型。
底层原理
T：基于Transformer的神经网络
P：通过大量数据预训练，掌握自然语言规律
G：基于上文计算概率，生成下一个token
模型部署方案
三种方案


云部署


优点
前期成本低
部署维护简单
弹性扩展
全球访问DNS


缺点
数据隐私
网络依赖
长期成本高




本地部署


优点
数据安全
不依赖外部网络
长期成本低
高度定制


缺点
初始成本高
维护复杂
部署周期长




开放API


优点
前期成本极低
无需部署
无需维护
全球访问


缺点
数据隐私
网络依赖
长期成本高
定制限制云服务




登录阿里云平台：https://www.aliyun.com/benefit?utm_content=se_1019887613
打开阿里云百炼：
打开控制台：
创建api-key：
体验模型将会消耗TokensApifox调用模型-H：添加请求头本地部署本地部署最简单的一种方案就是使用ollama,官网地址：https://ollama.com/

下载ollama：




选择模型下载：



选择模型版本（参数越大，能力越强，但所需显卡算力要求大），复制命令到cmd下载：



Apifox调用本地部署模型

在本地成功部署模型后，可进入ollama官网，在此页面往下滑，有个Blog，再点击thinking，继续往下滑，直到出现






调用大模型

遵循openAI规范（引领者）



常见参数
响应数据
token是什么在大语言模型中，Token是大模型处理文本的基本单位，
可以理解为模型“看得懂”的最小文本片段
用户输入的内容都需要转换成token，才能让大模型更好的处理
英文：一个token = 4个字符
中文：一个汉字 ≈ 1~2个token
大模型应用

注意区分产品（网页端对话的那种全叫产品）和大模型




AI应用开发技术架构
SpringAI

新项目推荐springAI，老项目推荐LangChain4j


对话机器人

openAI访问大模型的规范

操作步骤

引入依赖
引入管理依赖：管理与springAI有关的所有依赖以及指定版本
引入（基于ollama）模型起步依赖





配置模型
基于ollama
基于openAI





配置客户端


实例

新建项目（利用脚手架快速搭建）



引依赖



配置模型



配置客户端




使用
整段生成再输出




2. 流式输出Flux对象

会话日志

SpringAI利用AOP原理提供了AI会话时的拦截、增强等功能，也就是Advisor。
spring中已经封装好了各种Advisor




跨域
会话记忆

大模型是不具备记忆能力的，要想让大模型记住之前聊天的内容，唯一的办法就是把之前聊天的内容与新的提示词一起发给大模型。

LangChain4j
会话功能
快速入门

引入Langchain4j依赖
构建openAiChatModel对象
调用chat方法与大模型交互



baseUrl获取：



配了API KEY后一定要重启idea，因为还没生效，idea启动默认会读一次系统环境变量

打印日志信息
Spring整合LangChain4j
打印日志信息
AiServices工具类

传统model.chat方法在之后进行会话记忆等功能实现复杂，利用其提供的AiServices工具类更加方便




声明式使用
为接口创建代理对象，并将返回结果注入IOC容器
wiringModel = AiServiceWiringMode.EXPLICIT，表示创建完代理对象后选择手动装配
chatModel 表示选择哪个模型，langchain4j默认注入openAiChatModel





当然也可以不添加值，会默认自动装配


流式调用

出现乱码可以对接口进行指定编码，produces


消息注解

用于限定AI回答的范围


会话记忆

大模型是不具备记忆能力的，要想让大模型记住之前聊天的内容，唯一的办法就是把之前聊天的内容与新的提示词一起发给大模型。



langchain4j提供了一个接口用于定义会话记忆对象



会话隔离

原理



会话记忆持久化

刚才我们做的会话记忆，只要后端重启，会话记忆就没有了
原因



基于redis做持久化






RAG知识库RAG,Retrieval Augmented Generation,检索增强生成。通过检索外部知识库的方式增强大模型的生成能力。
原理


向量数据库：
Milvus、Chroma、Pinecone
RedisSearch(Reids)、pgvector(PostgreSQL)





如何往向量数据库中存储数据



如何检索向量数据库



总结
两个向量的余弦相似度越高，说明向量对应的文本相似度越高
向量数据库使用流程
借助于向量模型，把文档知识数据向量化后存储到向量数据库
用户输入的内容，借助于向量模型转化为向量后，与数据库中的向量通过计算余弦相似度的方式，找出相似度比较高的文本片段





快速入门
存储（构建向量数据库操作对象）

引入依赖



加载知识数据文档



构建向量数据库操作对象



把文档切割、向量化并存储到向量数据库中




检索（构建向量数据库检索对象）

构建向量数据库检索对象



配置向量数据库检索对象




外挂知识库示例





核心API
文档加载器
文档解析器
文档分割器
向量模型
向量数据库默认的向量数据库是基于内存的，重启就丢失了，需要持久化



为了能正确加载，需要做个配置




所以当向量库中有了数据后，这个@Bean就可以注释掉了



Tools工具




]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>定时任务框架</title>
    <url>/2025/09/01/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[定时任务框架
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>若依框架</title>
    <url>/2025/04/13/%E8%8B%A5%E4%BE%9D%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[若依搭建若依版本官方若依官方针对不同开发需求提供了多个版本的框架，每个版本都有其独特的特点和适用场景：

前后端混合版本：RuoYi结合了SpringBoot和Bootstrap的前端开发框架，适合快速构建传统的Web应用程序，其中前端和后端代码在同一项目中协同工作。
前后端分离版本：RuoYi-Vue利用SpringBoot作为后端开发框架，与Vue.js结合，实现了前后端分离的开发模式。这种架构有助于提高开发效率，前后端可以独立开发和部署，更适合现代化的Web应用开发。
微服务版本：RuoYi-Cloud基于Spring Cloud &amp; Alibaba微服务架构，为构建大型分布式系统提供了完整的解决方案。它支持服务发现、配置管理、负载均衡等微服务特性，适合需要高可扩展性和高可用性的企业级应用。
移动端版本：RuoYi-App采用Uniapp进行开发，结合了Vue.js的优势，可以实现跨平台的移动端应用开发。一次编写，多端运行的能力使得它成为开发iOS和Android应用的理想选择。

 
这些版本的框架为开发者提供了多样化的选择，无论是传统的Web应用、现代化的前后端分离应用，还是复杂的微服务架构和跨平台的移动端应用，都能找到合适的若依框架版本来满足开发需求。
非官方若依框架因其强大的功能和灵活性，吸引了众多第三方开发者基于其核心架构进行扩展和优化，从而形成了丰富的生态系统。
这些扩展不仅增强了若依框架的功能性，也满足了开发者在不同场景下的具体需求。例如：

RuoYi-Vue3（前端升级Vue3 Element Plus Vite）
https://github.com/yangzongzhuan/RuoYi-Vue3


RuoYi-Vue-Plus（后端集成Mybatis-Plus、Hutool、OSS存储、分布式锁等组件）
https://gitee.com/dromara/RuoYi-Vue-Plus



 
这些扩展版本的推出，使得若依框架能够更好地适应不同规模和类型的项目需求，从小型快速开发到大型企业级应用，都能提供相应的解决方案。开发者可以根据自己的具体需求选择合适的版本进行开发。
RuoYi-VuelRuoYi-Vue版本，采用了前后端分离的单体架构设计：
软件环境：JDK、MySQL 、Redis 、Maven、Node
技术选型：Spring Boot、Spring Security、MyBatis、Jwt、Vue3、Element-Plus
官方地址：https://gitee.com/y_project/RuoYi-Vue
扩展地址：https://gitee.com/ys-gitee/RuoYi-Vue3




官方推荐
课程版本




JDK  &gt;= 1.8
JDK  11


Mysql  &gt;= 5.7.0
MySQL  8


Redis  &gt;= 3.0
Redis  5（Win）


Maven  &gt;= 3.0
Maven  3.6


Node  &gt;= 12
Node  16（Vue3）





为了确保教学活动的顺利进行，建议所有学生在开始前安装并配置好这些软件的版本。
如果学生在安装或配置过程中遇到问题，可以联系播妞获取帮助，播妞将提供详细的安装文档和安装包，

运行后端项目初始化项目Git下载通过idea克隆若依源码，仓库地址：https://gitee.com/y_project/RuoYi-Vue.git
   
Maven构建使用idea打开项目后，等待环境检查（主要是Maven下载项目依赖）
 
MySQL相关导入sql1、创建数据库create schema ry-vue;
2、执行下图的sql脚本文件，完成导入
 
3、导入后ry-vue库内置30张表
 
配置信息在ruoyi-admin模块下，编辑resources目录下的application-druid.yml，修改数据库连接
# 数据源配置spring:    datasource:        type: com.alibaba.druid.pool.DruidDataSource        driverClassName: com.mysql.cj.jdbc.Driver        druid:            # 主库数据源            master:                url: 数据库地址                username: 数据库账号                password: 数据库密码
 
Redis相关启动在redis解压目录下，执行redis-server.exe redis.windows.conf启动
 
配置信息在ruoyi-admin模块下，resources目录下的application.yml，可以设置redis密码等相关信息
 
项目运行在ruoyi-admin模块下，运行com.ruoyi.RuoYiApplication.java，出现如下图表示启动成功
 
后端运行成功可以通过([http://localhost:8080 )访问，但是不会出现静态页面，可以继续参考下面步骤部署前端，然后通过前端地址来访问。
 
运行前端项目初始化项目进入开发目录下，使用vscode命令code打开项目
  # 克隆vue3项目git clone https://gitee.com/ys-gitee/RuoYi-Vue3.git# 通过vscode打开项目code ./RuoYi-Vue3
项目运行在vscode终端中输入以下命令：
# 安装依赖npm install# 建议不要直接使用 cnpm 安装依赖，会有各种诡异的 bug。可以通过如下操作解决 npm 下载速度慢的问题npm install --registry=https://registry.npmmirror.com# 启动服务npm run dev
 
打开浏览器，输入：([http://localhost:80) 默认账户/密码 admin/admin123）若能正确展示登录页面，并能成功登录，菜单及页面展示正常，则表明环境搭建成功
 
入门案例在若依项目成功搭建之后，深入了解其代码生成器功能是掌握框架的重要一环。
接下来，我们将利用若依框架的代码生成器实现CRM系统中的课程管理功能，这将使我们能够实际体验并掌握如何在项目中有效使用这一工具。
功能需求
实现CRM系统中的课程管理功能，涵盖增加、删除、修改和查询课程信息的完整前后端代码。
原型地址：https://app.mockplus.cn/run/prototype/_lwaPYSV9Ue6/byFT7QUzmCqJ/2AadzZnerRIDo?cps=collapse&amp;isShare=true

 
步骤分析1、准备课程表结构和数据sql文件，导入到数据库中
2、登录系统（系统工具 -&gt; 代码生成 -&gt; 导入课程表）
3、代码生成列表中找到课程表（可预览、编辑、同步、删除生成配置）
4、点击生成代码会得到一个ruoyi.zip
5、执行sql文件导入菜单，按照包内目录结构复制到自己的项目中即可
代码生成提供课程表准备课程表结构和数据sql文件，导入到数据库中
 
系统导入登录系统（系统工具 -&gt; 代码生成 -&gt; 导入课程表）
 
配置代码代码生成列表中找到课程表（可预览、编辑、同步、删除生成配置）
    
点击生成点击生成代码，得到一个ruoyi.zip
   
解压后得到：后端代码、前端代码、菜单sql
  
代码导入导入课程菜单执行sql脚本，导入菜单数据
 
导入后端代码将生成的后端代码和mappep文件，导入ruoyi-admin模块中 
 

注意：如果导入后的代码重启后没生效，可以通过maven先clean再启动

导入前端代码将生成的前端代码，导入ruoyi-ui模块中
   
访问测试代码生成器默认生成的课程管理模块在系统工具菜单下，打开测试CRUD功能
   
功能详解我们将对若依的通用功能进行详解。本章内容分为三个重点部分：
系统管理权限系统演示若依提供了企业级通用权限系统，我们这里拿CRM系统先给大家演示下：
地址：https://huike-crm.itheima.net/

demo账号（超级管理员），可以查看所有功能菜单

zhangsan账号（市场专员），可以查看线索管理菜单

yueyue账号（销售专员），可以查看商机、合同等菜单


 
RBAClRBAC（基于角色的访问控制）是一种广泛使用的访问控制模型，通过角色来分配和管理用户的菜单权限。
 
表关系 
 
案例创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。
 
实现步骤：
①创建菜单
②创建角色，并分配权限
③创建用户，并关联角色
 
数据字典介绍若依内置的数据字典，用于维护系统中常见的静态数据。例如：性别、状态…
 
功能包括：字典类型管理、字典数据管理
  
表关系 
案例将课程管理的学科字段改为数据字典维护。
 
实现步骤：
①添加字典类型和数据
 
②修改代码生成信息
 
③下载代码，导入前端
 
参数设置参数设置：对系统中的参数进行动态维护。
 
关闭登录验证码

通知公告RuoYi的通知公告功能提供了一个方便的方式来发布和管理通知、公告和新闻等信息。管理员可以创建、编辑和删除通知（支持富文本编辑和附件上传）。
系统将信息发送给指定的用户、部门或角色。用户可以通过系统界面或电子邮件接收通知，从而确保信息及时传达（这部分需要自己开发）。
通知公告功能有助于组织内部沟通和信息传递，提高了工作效率和信息共享。
 
日志管理登录日志

记录用户的登录信息，包括登录时间和地点（IP地址）。
帮助管理员监控登录行为，及时发现任何可疑的登录尝试。
同样提供搜索和筛选功能，方便查找特定用户的登录历史。

 
操作日志

记录用户在系统中的所有操作，如查看、修改数据等。
帮助管理员检查谁做了什么，以及何时做的，确保数据准确无误。
可以快速搜索和找到特定的操作记录，便于管理和审查。

 
系统监控监控相关若依提供了一些列强大的监控工具，能够帮助开发者和运维快速了解应用程序的性能状态。
 

在线用户：
管理员可以看到当前谁在系统里，他们什么时候登录的，从哪里登录的，属于哪个部门。
如果有人没权限还赖着不走，管理员可以一键让他们下线，保证系统的安全。


数据监控：
管理员可以实时看到系统的各项指标，比如资源使用情况，数据库状态等。
通过图表可以直观地看出系统是否健康，如果出现问题，系统会发出警报。


服务监控：
管理员可以监控系统中各个服务是否正常运行，以及它们的性能指标。
如果服务出现问题，系统会立即通知管理员，并通过仪表板展示，方便管理员快速了解情况。


缓存监控：
管理员可以监控系统的缓存使用情况，比如缓存是否经常被用到，缓存的大小等。
系统还可以自动清理缓存，保持数据的新鲜度，如果缓存有问题，也会发出警报。



定时任务介绍若依为定时任务功能提供方便友好的web界面，实现动态管理任务。
 
案例每间隔5秒，控制台输出系统时间。
 
实现步骤：
①创建任务类 
②添加任务规则
 

任务名称：自定义，如：定时查询任务状态
任务分组：根据字典sys_job_group配置，可自行进行配置
调用目标字符串：设置后台任务方法名称参数
执行表达式：可查询官方cron表达式介绍
执行策略：定时任务自定义执行策略
并发执行：是否需要多个任务间同时执行

③启动任务
  
系统工具表单构建介绍
允许用户通过拖放等可视化操作创建表单，比如用来收集数据的表格或调查问卷。
可以自定义表单的各个部分，比如添加不同的输入项和设置验证规则，无需编写代码。
提供了导出数据、导入数据、分享表单和设置权限的功能，方便数据管理和共享。

 
案例通过表单构建工具，单独制作一个添加课程的表单页面。
 
实现步骤：
①制作表单并导出
②复制到前端工程 
③创建动态菜单
 
代码生成
自动化工具，可以快速生成项目中常用的代码，如数据库操作类、后端控制器、前端页面等。
支持根据数据库的表结构反向生成代码，减少手动编写的工作量。
提供三种生成模板：单表、 树表、主子表（一对多），可以生成适用于Spring Boot、MyBatis等流行框架的代码，提高开发效率和代码质量。
树表是一种展示层级数据的表格，能展开折叠，清晰呈现父子关系，便于管理。

 
代码生成配置主表实现细节：
 
系统接口
Swagger，能够自动生成 API 的同步在线文档，并提供Web界面进行接口调用和测试。

 
项目结构在功能的讲解过程中，涉及的前后端项目的结构和配置文件，我们还比较陌生，为了更好的使用若依进行项目开发，所以接下来，我们开始进入项目结构这部分内容的学习
后端结构com.ruoyi├── ruoyi-admin      // 后台服务模块│       └── web                           // 内置功能的表现层│       └── RuoYiApplication              // 若依项目启动类    ├── ruoyi-common     // 通用工具模块│       └── annotation                    // 自定义注解│       └── config                        // 全局配置│       └── constant                      // 通用常量│       └── core                          // 核心控制│       └── enums                         // 通用枚举│       └── exception                     // 通用异常│       └── filter                        // 过滤器处理│       └── utils                         // 通用类处理│       └── xss                           // 自定义xss校验├── ruoyi-framework  // 框架核心模块│       └── aspectj                       // AOP配置│       └── config                        // 系统配置│       └── datasource                    // 多数据源配置 │       └── interceptor                   // 拦截器│       └── manager                       // 异步处理│       └── security                      // 权限控制│       └── web                           // 前端控制├── ruoyi-generator  // 代码生成模块（可移除）              ├── ruoyi-quartz     // 定时任务模块（可移除）          ├── ruoyi-system     // 系统代码模块│       └── domain                        // 系统代码的实体类│       └── mapper                        // 系统代码的持久层│       └── service                       // 系统代码的业务层
 
项目中配置项目中的配置文件都在ruoyi-admin模块下，如下图：
  

i18n：国际化处理
META-INF：存储了项目的元信息（描述数据的数据），无需修改
mybatis：mybatis相关的配置信息
application.yml：项目中的核心配置
application-druid.yml：数据库连接配置
banner.txt：默认的banner图标信息，项目启动，控制台打印显示
logback.xml：日志配置

最主要的两个配置文件：application.yml
# 项目相关配置ruoyi:  # 名称  name: RuoYi  # 版本  version: 3.8.7  # 版权年份  copyrightYear: 2024  # 文件路径 示例（ Windows配置D:/ruoyi/uploadPath，Linux配置 /home/ruoyi/uploadPath）  profile: D:/ruoyi/uploadPath  # 获取ip地址开关  addressEnabled: false  # 验证码类型 math 数字计算 char 字符验证  captchaType: math# 开发环境配置server:  # 服务器的HTTP端口，默认为8080  port: 8080  servlet:    # 应用的访问路径    context-path: /  tomcat:    # tomcat的URI编码    uri-encoding: UTF-8    # 连接数满后的排队数，默认为100    accept-count: 1000    threads:      # tomcat最大线程数，默认为200      max: 800      # Tomcat启动初始化的线程数，默认值10      min-spare: 100# 日志配置logging:  level:    com.ruoyi: debug    org.springframework: warn# 用户配置user:  password:    # 密码最大错误次数    maxRetryCount: 5    # 密码锁定时间（默认10分钟）    lockTime: 10# Spring配置spring:  # 资源信息  messages:    # 国际化资源文件路径    basename: i18n/messages  profiles:    active: druid  # 文件上传  servlet:    multipart:      # 单个文件大小      max-file-size: 10MB      # 设置总上传的文件大小      max-request-size: 20MB  # 服务模块  devtools:    restart:      # 热部署开关      enabled: true  # redis 配置  redis:    # 地址    host: localhost    # 端口，默认为6379    port: 6379    # 数据库索引    database: 0    # 密码    password: 123456    # 连接超时时间    timeout: 10s    lettuce:      pool:        # 连接池中的最小空闲连接        min-idle: 0        # 连接池中的最大空闲连接        max-idle: 8        # 连接池的最大数据库连接数        max-active: 8        # #连接池最大阻塞等待时间（使用负值表示没有限制）        max-wait: -1ms# token配置token:  # 令牌自定义标识  header: Authorization  # 令牌密钥  secret: abcdefghijklmnopqrstuvwxyz  # 令牌有效期（默认30分钟）  expireTime: 30# MyBatis配置mybatis:  # 搜索指定包别名  typeAliasesPackage: com.ruoyi.**.domain  # 配置mapper的扫描，找到所有的mapper.xml映射文件  mapperLocations: classpath*:mapper/**/*Mapper.xml  # 加载全局的配置文件  configLocation: classpath:mybatis/mybatis-config.xml# PageHelper分页插件pagehelper:  helperDialect: mysql  supportMethodsArguments: true  params: count=countSql# Swagger配置swagger:  # 是否开启swagger  enabled: true  # 请求前缀  pathMapping: /dev-api# 防止XSS攻击xss:  # 过滤开关  enabled: true  # 排除链接（多个用逗号分隔）  excludes: /system/notice  # 匹配链接  urlPatterns: /system/*,/monitor/*,/tool/*
模块依赖关系各个模块之间的依赖关系：
  
前端结构ruoyi-vue3├── bin                        // 执行脚本├── html                       // IE低版本提示页├── node_modules               // 第三方依赖库├── public                     // 公共资源│   ├── favicon.ico            // favicon图标├── src                        // 源代码│   ├── api                    // 所有请求│   ├── /assets                 // 静态资源│   ├── components             // 全局公用组件│   ├── directive              // 全局指令│   ├── layout                 // 布局│   ├── plugins                // 通用插件│   ├── router                 // 路由配置│   ├── store                  // 状态管理│   ├── utils                  // 全局公用方法│   ├── views                  // 视图组件│   ├── App.vue                // 入口组件│   ├── main.js                // 入口文件│   ├── permission.js          // 权限管理│   └── settings.js            // 系统配置├── vite                       // 构建工具├── .env.development           // 开发环境配置├── .env.production            // 生产环境配置├── .env.staging               // 测试环境配置├── .gitignore                 // git 忽略项├── index.html                 // 入口页面├── package.json               // 项目配置文件（相当于pom.xml）└── vue.config.js              // Vue项目的配置信息（相当于application.yml）
 
表结构介绍ruoyi-vue数据库设计包含了多个表结构，用于支持系统的各种功能模块。
这些表可以根据它们的功能和用途进行分类，以便在后期使用时能够快速定位和理解。以下是对这些表结构的分类和简要说明：
 
 
源码阅读本章我们将围绕入门案例生成的课程管理进行讲解，包含前后端代码的分析，以及前后端代码交互的流程，通过这部分的学习，不仅能让我们掌握若依的基础业务逻辑，在此基础上还能为我们日后的定制开发提供强有力的支撑。
前端代码分析找到src/views/course/course/index.vue文件，护理项目的前端代码已经添加了详细的注释，如下：
&lt;template&gt;  &lt;div class=&quot;app-container&quot;&gt;    &lt;!-- 搜索表单 start --&gt;    &lt;el-form :model=&quot;queryParams&quot; ref=&quot;queryRef&quot; :inline=&quot;true&quot; v-show=&quot;showSearch&quot; label-width=&quot;68px&quot;&gt;         &lt;el-form-item label=&quot;课程编码&quot; prop=&quot;code&quot;&gt;        &lt;el-input          v-model=&quot;queryParams.code&quot;          placeholder=&quot;请输入课程编码&quot;          clearable          @keyup.enter=&quot;handleQuery&quot;        /&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;课程学科&quot; prop=&quot;subject&quot;&gt;        &lt;el-select v-model=&quot;queryParams.subject&quot; placeholder=&quot;请选择课程学科&quot; clearable&gt;          &lt;el-option            v-for=&quot;dict in course_subject&quot;            :key=&quot;dict.value&quot;            :label=&quot;dict.label&quot;            :value=&quot;dict.value&quot;          /&gt;        &lt;/el-select&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt;        &lt;el-input          v-model=&quot;queryParams.name&quot;          placeholder=&quot;请输入课程名称&quot;          clearable          @keyup.enter=&quot;handleQuery&quot;        /&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;applicablePerson&quot;&gt;        &lt;el-input          v-model=&quot;queryParams.applicablePerson&quot;          placeholder=&quot;请输入适用人群&quot;          clearable          @keyup.enter=&quot;handleQuery&quot;        /&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot; icon=&quot;Search&quot; @click=&quot;handleQuery&quot;&gt;搜索&lt;/el-button&gt;        &lt;el-button icon=&quot;Refresh&quot; @click=&quot;resetQuery&quot;&gt;重置&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-form&gt;    &lt;!-- 搜索表单 end --&gt;    &lt;!-- 按钮区域 start --&gt;    &lt;el-row :gutter=&quot;10&quot; class=&quot;mb8&quot;&gt;      &lt;el-col :span=&quot;1.5&quot;&gt;        &lt;el-button          type=&quot;primary&quot;          plain          icon=&quot;Plus&quot;          @click=&quot;handleAdd&quot;          v-hasPermi=&quot;[&#x27;course:course:add&#x27;]&quot;        &gt;新增&lt;/el-button&gt;      &lt;/el-col&gt;      &lt;el-col :span=&quot;1.5&quot;&gt;        &lt;el-button          type=&quot;success&quot;          plain          icon=&quot;Edit&quot;          :disabled=&quot;single&quot;          @click=&quot;handleUpdate&quot;          v-hasPermi=&quot;[&#x27;course:course:edit&#x27;]&quot;        &gt;修改&lt;/el-button&gt;      &lt;/el-col&gt;      &lt;el-col :span=&quot;1.5&quot;&gt;        &lt;el-button          type=&quot;danger&quot;          plain          icon=&quot;Delete&quot;          :disabled=&quot;multiple&quot;          @click=&quot;handleDelete&quot;          v-hasPermi=&quot;[&#x27;course:course:remove&#x27;]&quot;        &gt;删除&lt;/el-button&gt;      &lt;/el-col&gt;      &lt;el-col :span=&quot;1.5&quot;&gt;        &lt;el-button          type=&quot;warning&quot;          plain          icon=&quot;Download&quot;          @click=&quot;handleExport&quot;          v-hasPermi=&quot;[&#x27;course:course:export&#x27;]&quot;        &gt;导出&lt;/el-button&gt;      &lt;/el-col&gt;      &lt;right-toolbar v-model:showSearch=&quot;showSearch&quot; @queryTable=&quot;getList&quot;&gt;&lt;/right-toolbar&gt;    &lt;/el-row&gt;    &lt;!-- 按钮区域end --&gt;    &lt;!-- 数据展示表格 start --&gt;    &lt;el-table v-loading=&quot;loading&quot; :data=&quot;courseList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;       &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;      &lt;el-table-column label=&quot;课程id&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;      &lt;el-table-column label=&quot;课程编码&quot; align=&quot;center&quot; prop=&quot;code&quot; /&gt;      &lt;el-table-column label=&quot;课程学科&quot; align=&quot;center&quot; prop=&quot;subject&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;dict-tag :options=&quot;course_subject&quot; :value=&quot;scope.row.subject&quot;/&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;课程名称&quot; align=&quot;center&quot; prop=&quot;name&quot; /&gt;      &lt;el-table-column label=&quot;价格&quot; align=&quot;center&quot; prop=&quot;price&quot; /&gt;      &lt;el-table-column label=&quot;适用人群&quot; align=&quot;center&quot; prop=&quot;applicablePerson&quot; /&gt;      &lt;el-table-column label=&quot;课程介绍&quot; align=&quot;center&quot; prop=&quot;info&quot; /&gt;      &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#x27;course:course:edit&#x27;]&quot;&gt;修改&lt;/el-button&gt;          &lt;el-button link type=&quot;primary&quot; icon=&quot;Delete&quot; @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#x27;course:course:remove&#x27;]&quot;&gt;删除&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;    &lt;!-- 数据展示表格 end --&gt;        &lt;!-- 分页区域 start --&gt;    &lt;pagination      v-show=&quot;total&gt;0&quot;      :total=&quot;total&quot;      v-model:page=&quot;queryParams.pageNum&quot;      v-model:limit=&quot;queryParams.pageSize&quot;      @pagination=&quot;getList&quot;    /&gt;    &lt;!-- 分页区域 end --&gt;    &lt;!-- 添加或修改课程管理对话框 --&gt;    &lt;el-dialog :title=&quot;title&quot; v-model=&quot;open&quot; width=&quot;500px&quot; append-to-body&gt;      &lt;el-form ref=&quot;courseRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt;        &lt;el-form-item label=&quot;课程编码&quot; prop=&quot;code&quot;&gt;          &lt;el-input v-model=&quot;form.code&quot; placeholder=&quot;请输入课程编码&quot; /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;课程学科&quot; prop=&quot;subject&quot;&gt;          &lt;el-select v-model=&quot;form.subject&quot; placeholder=&quot;请选择课程学科&quot;&gt;            &lt;el-option              v-for=&quot;dict in course_subject&quot;              :key=&quot;dict.value&quot;              :label=&quot;dict.label&quot;              :value=&quot;dict.value&quot;            &gt;&lt;/el-option&gt;          &lt;/el-select&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt;          &lt;el-input v-model=&quot;form.name&quot; placeholder=&quot;请输入课程名称&quot; /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;价格&quot; prop=&quot;price&quot;&gt;          &lt;el-input v-model=&quot;form.price&quot; placeholder=&quot;请输入价格&quot; /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;applicablePerson&quot;&gt;          &lt;el-input v-model=&quot;form.applicablePerson&quot; placeholder=&quot;请输入适用人群&quot; /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;课程介绍&quot; prop=&quot;info&quot;&gt;          &lt;el-input v-model=&quot;form.info&quot; placeholder=&quot;请输入课程介绍&quot; /&gt;        &lt;/el-form-item&gt;      &lt;/el-form&gt;      &lt;template #footer&gt;        &lt;div class=&quot;dialog-footer&quot;&gt;          &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm&quot;&gt;确 定&lt;/el-button&gt;          &lt;el-button @click=&quot;cancel&quot;&gt;取 消&lt;/el-button&gt;        &lt;/div&gt;      &lt;/template&gt;    &lt;/el-dialog&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup name=&quot;Course&quot;&gt;// 引入后端api接口import &#123; listCourse, getCourse, delCourse, addCourse, updateCourse &#125; from &quot;@/api/course/course&quot;;// 获取当前实例代理对象，用于访问组件数据、方法const &#123; proxy &#125; = getCurrentInstance();// 获取课程学科的数据字典const &#123; course_subject &#125; = proxy.useDict(&#x27;course_subject&#x27;);// 列表数据const courseList = ref([]);// 是否显示弹框const open = ref(false);// 是否显示加载状态const loading = ref(true);// 是否显示搜索栏const showSearch = ref(true);// 复选框，被选中id的数组const ids = ref([]);// 复选框，是否单选，用于高亮修改、删除按钮const single = ref(true);// 复选框，是否多选，仅高亮删除按钮const multiple = ref(true);// 总（记录）条数const total = ref(0);// 用于区分新增、修改对话框标题const title = ref(&quot;&quot;);// 定义reactive响应式对象const data = reactive(&#123;  // 新增或修改表单数据  form: &#123;&#125;,  // 搜索条件参数  queryParams: &#123;    pageNum: 1,    pageSize: 10,    code: null,    subject: null,    name: null,    applicablePerson: null,  &#125;,  // 表单校验规则  rules: &#123;    code: [      &#123; required: true, message: &quot;课程编码不能为空&quot;, trigger: &quot;blur&quot; &#125;    ],    subject: [      &#123; required: true, message: &quot;课程学科不能为空&quot;, trigger: &quot;change&quot; &#125;    ],    name: [      &#123; required: true, message: &quot;课程名称不能为空&quot;, trigger: &quot;blur&quot; &#125;    ],    price: [      &#123; required: true, message: &quot;价格不能为空&quot;, trigger: &quot;blur&quot; &#125;    ],    applicablePerson: [      &#123; required: true, message: &quot;适用人群不能为空&quot;, trigger: &quot;blur&quot; &#125;    ],    info: [      &#123; required: true, message: &quot;课程介绍不能为空&quot;, trigger: &quot;blur&quot; &#125;    ],  &#125;&#125;);// 将data对象的三个属性，转换为ref响应式对象const &#123; queryParams, form, rules &#125; = toRefs(data);/** 查询课程管理列表 */function getList() &#123;  loading.value = true;  listCourse(queryParams.value).then(response =&gt; &#123;    courseList.value = response.rows;    total.value = response.total;    loading.value = false;  &#125;);&#125;// 取消按钮function cancel() &#123;  open.value = false;  reset();&#125;// 表单重置function reset() &#123;  form.value = &#123;    id: null,    code: null,    subject: null,    name: null,    price: null,    applicablePerson: null,    info: null,    createTime: null,    updateTime: null  &#125;;  proxy.resetForm(&quot;courseRef&quot;);&#125;/** 搜索按钮操作 */function handleQuery() &#123;  queryParams.value.pageNum = 1;  getList();&#125;/** 重置按钮操作 */function resetQuery() &#123;  proxy.resetForm(&quot;queryRef&quot;);  handleQuery();&#125;// 多选框选中数据function handleSelectionChange(selection) &#123;  ids.value = selection.map(item =&gt; item.id);  single.value = selection.length != 1;  multiple.value = !selection.length;&#125;/** 新增按钮操作 */function handleAdd() &#123;  reset();  open.value = true;  title.value = &quot;添加课程管理&quot;;&#125;/** 修改按钮操作 */function handleUpdate(row) &#123;  reset();  const _id = row.id || ids.value  getCourse(_id).then(response =&gt; &#123;    form.value = response.data;    open.value = true;    title.value = &quot;修改课程管理&quot;;  &#125;);&#125;/** 提交按钮 */function submitForm() &#123;  proxy.$refs[&quot;courseRef&quot;].validate(valid =&gt; &#123;    if (valid) &#123;      if (form.value.id != null) &#123;        updateCourse(form.value).then(response =&gt; &#123;          proxy.$modal.msgSuccess(&quot;修改成功&quot;);          open.value = false;          getList();        &#125;);      &#125; else &#123;        addCourse(form.value).then(response =&gt; &#123;          proxy.$modal.msgSuccess(&quot;新增成功&quot;);          open.value = false;          getList();        &#125;);      &#125;    &#125;  &#125;);&#125;/** 删除按钮操作 */function handleDelete(row) &#123;  const _ids = row.id || ids.value;  proxy.$modal.confirm(&#x27;是否确认删除课程管理编号为&quot;&#x27; + _ids + &#x27;&quot;的数据项？&#x27;).then(function() &#123;    return delCourse(_ids);  &#125;).then(() =&gt; &#123;    getList();    proxy.$modal.msgSuccess(&quot;删除成功&quot;);  &#125;).catch(() =&gt; &#123;&#125;);&#125;/** 导出按钮操作 */function handleExport() &#123;  proxy.download(&#x27;course/course/export&#x27;, &#123;     ...queryParams.value  &#125;, `course_$&#123;new Date().getTime()&#125;.xlsx`)&#125;// 页面加载时执行-查询课程管理列表getList();&lt;/script&gt;
后端代码分析CourseControllerruoyi-admin模块下找到这个类：com.ruoyi.web.controller.course.CourseController里面有5个对应的方法接口，详细代码如下：
package com.sky.course.controller;import com.sky.common.annotation.Log;import com.sky.common.core.controller.BaseController;import com.sky.common.core.domain.AjaxResult;import com.sky.common.core.page.TableDataInfo;import com.sky.common.enums.BusinessType;import com.sky.common.utils.poi.ExcelUtil;import com.sky.course.domain.Course;import com.sky.course.service.ICourseService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletResponse;import java.util.List;/** * 课程管理Controller * * @author itheima */@RestController@RequestMapping(&quot;/course/course&quot;)public class CourseController extends BaseController&#123;    @Autowired    private ICourseService courseService;    /**     * 查询课程管理列表     */    @PreAuthorize(&quot;@ss.hasPermi(&#x27;course:course:list&#x27;)&quot;)    @GetMapping(&quot;/list&quot;)    public TableDataInfo list(Course course)    &#123;        //1. 开启分页        startPage();        //2. 查询课程列表        List&lt;Course&gt; list = courseService.selectCourseList(course);        //3. 返回表格分页数据对象        return getDataTable(list);    &#125;    /**     * 导出课程管理列表     */    @PreAuthorize(&quot;@ss.hasPermi(&#x27;course:course:export&#x27;)&quot;)    @Log(title = &quot;课程管理&quot;, businessType = BusinessType.EXPORT)    @PostMapping(&quot;/export&quot;)    public void export(HttpServletResponse response, Course course)    &#123;        List&lt;Course&gt; list = courseService.selectCourseList(course);        ExcelUtil&lt;Course&gt; util = new ExcelUtil&lt;Course&gt;(Course.class);        util.exportExcel(response, list, &quot;课程管理数据&quot;);    &#125;    /**     * 获取课程管理详细信息     */    @PreAuthorize(&quot;@ss.hasPermi(&#x27;course:course:query&#x27;)&quot;)    @GetMapping(value = &quot;/&#123;id&#125;&quot;)    public AjaxResult getInfo(@PathVariable(&quot;id&quot;) Long id)    &#123;        return success(courseService.selectCourseById(id));    &#125;    /**     * 新增课程管理     */    @PreAuthorize(&quot;@ss.hasPermi(&#x27;course:course:add&#x27;)&quot;)    @Log(title = &quot;课程管理&quot;, businessType = BusinessType.INSERT)    @PostMapping    public AjaxResult add(@RequestBody Course course)    &#123;        return toAjax(courseService.insertCourse(course));    &#125;    /**     * 修改课程管理     */    @PreAuthorize(&quot;@ss.hasPermi(&#x27;course:course:edit&#x27;)&quot;)    @Log(title = &quot;课程管理&quot;, businessType = BusinessType.UPDATE)    @PutMapping    public AjaxResult edit(@RequestBody Course course)    &#123;        return toAjax(courseService.updateCourse(course));    &#125;    /**     * 删除课程管理     */    @PreAuthorize(&quot;@ss.hasPermi(&#x27;course:course:remove&#x27;)&quot;)    @Log(title = &quot;课程管理&quot;, businessType = BusinessType.DELETE)	@DeleteMapping(&quot;/&#123;ids&#125;&quot;)    public AjaxResult remove(@PathVariable Long[] ids)    &#123;        return toAjax(courseService.deleteCourseByIds(ids));    &#125;&#125;
BaseControllerController继承了BaseController，其中BaseController详细定义如下图：
 
TableDataInfo分页查询统一返回对象：表格分页数据对象
 
AjaxResult增删改查统一返回对象：操作消息提醒
 
BaseEntity所有实体类默认继承的BaseEntity基类
 
权限注解@PreAuthorize 注解是 Spring Security 框架中用来做权限检查的。
它在运行方法前先验证权限，权限够就放行，不够就拦截。
 
权限控制流程图
  
前后端交互流程查询课程管理列表
接口文档 
跨域在前端开发中，跨域是一个常见的问题，特别是在使用Vue框架进行开发时。跨域是指在浏览器中发送的AJAX请求的目标地址与当前页面的地址不在同一个域下，这会导致浏览器的同源策略产生限制，从而阻止了跨域请求的发送。然而，我们可以通过代理服务器来解决这个问题。
 
代理服务器是位于客户端和目标服务器之间的一台服务器，它接收客户端发送的请求，并将请求转发给目标服务器。通过在代理服务器上进行请求转发，可以绕过浏览器的同源策略限制，从而实现跨域请求。
在vue.config.js文件中添加以下内容：
  
二次开发接下来我们将利用这些知识，实现外卖管理系统的业务功能开发，本章培养的是大家如何基于若依进行二次开发的技能，所以这里我们拿其中一个菜品管理功能给同学们进行讲解
模块定制若依框架修改器若依框架修改器是一个可以一键修改RuoYi框架包名、项目名等的工具。
地址：https://gitee.com/lpf_project/RuoYi-MT/releases
资料中已提供，将项目打成压缩包，直接修改即可：
 
 
新建业务模块新建子模块在sky父工程下创建sky-merchant子模块，在pom.xml中导入核心模块依赖
 
版本锁定在RuoYi-Vue父工程pom.xml中进行版本锁定
  
添加模块依赖在ruoyi-admin模块pom.xml中添加模块依赖
  
菜品管理利用若依代码生成器（主子表模板），生成菜品管理的前后端代码。
  
代码生成①准备SQL并导入数据库
 
②配置代码生成信息
 
③下载代码并导入项目
 
升级改造页面组件找到src/views/merchant/dish/index.vue文件，改造菜品查询列表和口味列表，如下：
&lt;template&gt;  &lt;div class=&quot;app-container&quot;&gt;    &lt;el-form :model=&quot;queryParams&quot; ref=&quot;queryRef&quot; :inline=&quot;true&quot; v-show=&quot;showSearch&quot; label-width=&quot;68px&quot;&gt;      &lt;el-form-item label=&quot;菜品名称&quot; prop=&quot;name&quot;&gt;        &lt;el-input          v-model=&quot;queryParams.name&quot;          placeholder=&quot;请输入菜品名称&quot;          clearable          @keyup.enter=&quot;handleQuery&quot;        /&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;售卖状态&quot; prop=&quot;status&quot;&gt;        &lt;el-select v-model=&quot;queryParams.status&quot; placeholder=&quot;请选择售卖状态&quot; clearable&gt;          &lt;el-option            v-for=&quot;dict in dish_status&quot;            :key=&quot;dict.value&quot;            :label=&quot;dict.label&quot;            :value=&quot;dict.value&quot;          /&gt;        &lt;/el-select&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot; icon=&quot;Search&quot; @click=&quot;handleQuery&quot;&gt;搜索&lt;/el-button&gt;        &lt;el-button icon=&quot;Refresh&quot; @click=&quot;resetQuery&quot;&gt;重置&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-form&gt;    &lt;el-row :gutter=&quot;10&quot; class=&quot;mb8&quot;&gt;      &lt;el-col :span=&quot;1.5&quot;&gt;        &lt;el-button          type=&quot;primary&quot;          plain          icon=&quot;Plus&quot;          @click=&quot;handleAdd&quot;          v-hasPermi=&quot;[&#x27;merchant:dish:add&#x27;]&quot;        &gt;新增&lt;/el-button&gt;      &lt;/el-col&gt;      &lt;el-col :span=&quot;1.5&quot;&gt;        &lt;el-button          type=&quot;success&quot;          plain          icon=&quot;Edit&quot;          :disabled=&quot;single&quot;          @click=&quot;handleUpdate&quot;          v-hasPermi=&quot;[&#x27;merchant:dish:edit&#x27;]&quot;        &gt;修改&lt;/el-button&gt;      &lt;/el-col&gt;      &lt;el-col :span=&quot;1.5&quot;&gt;        &lt;el-button          type=&quot;danger&quot;          plain          icon=&quot;Delete&quot;          :disabled=&quot;multiple&quot;          @click=&quot;handleDelete&quot;          v-hasPermi=&quot;[&#x27;merchant:dish:remove&#x27;]&quot;        &gt;删除&lt;/el-button&gt;      &lt;/el-col&gt;      &lt;el-col :span=&quot;1.5&quot;&gt;        &lt;el-button          type=&quot;warning&quot;          plain          icon=&quot;Download&quot;          @click=&quot;handleExport&quot;          v-hasPermi=&quot;[&#x27;merchant:dish:export&#x27;]&quot;        &gt;导出&lt;/el-button&gt;      &lt;/el-col&gt;      &lt;right-toolbar v-model:showSearch=&quot;showSearch&quot; @queryTable=&quot;getList&quot;&gt;&lt;/right-toolbar&gt;    &lt;/el-row&gt;    &lt;el-table v-loading=&quot;loading&quot; :data=&quot;dishList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;      &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;      &lt;!-- &lt;el-table-column label=&quot;主键&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt; --&gt;      &lt;el-table-column label=&quot;菜品名称&quot; align=&quot;center&quot; prop=&quot;name&quot; /&gt;      &lt;!-- &lt;el-table-column label=&quot;售价&quot; align=&quot;center&quot; prop=&quot;price&quot; /&gt; --&gt;      &lt;el-table-column label=&quot;售价&quot; align=&quot;center&quot;&gt;      &lt;template #default=&quot;&#123; row &#125;&quot;&gt;        &lt;span&gt;￥&#123;&#123; row.price &#125;&#125;&lt;/span&gt;      &lt;/template&gt;    &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;图片&quot; align=&quot;center&quot; prop=&quot;image&quot; width=&quot;100&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;image-preview :src=&quot;scope.row.image&quot; :width=&quot;50&quot; :height=&quot;50&quot;/&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;售卖状态&quot; align=&quot;center&quot; prop=&quot;status&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;dict-tag :options=&quot;dish_status&quot; :value=&quot;scope.row.status&quot;/&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;更新时间&quot; align=&quot;center&quot; prop=&quot;updateTime&quot; width=&quot;180&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;         &lt;span&gt;&#123;&#123; parseTime(scope.row.updateTime, &#x27;&#123;y&#125;-&#123;m&#125;-&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;&#x27;) &#125;&#125;&lt;/span&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#x27;merchant:dish:edit&#x27;]&quot;&gt;修改&lt;/el-button&gt;          &lt;el-button link type=&quot;primary&quot; icon=&quot;Delete&quot; @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#x27;merchant:dish:remove&#x27;]&quot;&gt;删除&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;        &lt;pagination      v-show=&quot;total&gt;0&quot;      :total=&quot;total&quot;      v-model:page=&quot;queryParams.pageNum&quot;      v-model:limit=&quot;queryParams.pageSize&quot;      @pagination=&quot;getList&quot;    /&gt;    &lt;!-- 添加或修改菜品管理对话框 --&gt;    &lt;el-dialog :title=&quot;title&quot; v-model=&quot;open&quot; width=&quot;600px&quot; append-to-body&gt;      &lt;el-form ref=&quot;dishRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt;        &lt;el-form-item label=&quot;菜品名称&quot; prop=&quot;name&quot;&gt;          &lt;el-input v-model=&quot;form.name&quot; placeholder=&quot;请输入菜品名称&quot; /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;售价&quot; prop=&quot;price&quot;&gt;          &lt;el-input v-model=&quot;form.price&quot; placeholder=&quot;请输入售价&quot; /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;图片&quot; prop=&quot;image&quot;&gt;          &lt;image-upload v-model=&quot;form.image&quot;/&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;描述信息&quot; prop=&quot;description&quot;&gt;          &lt;el-input v-model=&quot;form.description&quot; placeholder=&quot;请输入描述信息&quot; /&gt;        &lt;/el-form-item&gt;        &lt;el-form-item label=&quot;售卖状态&quot; prop=&quot;status&quot;&gt;          &lt;el-select v-model=&quot;form.status&quot; placeholder=&quot;请选择售卖状态&quot;&gt;            &lt;el-option              v-for=&quot;dict in dish_status&quot;              :key=&quot;dict.value&quot;              :label=&quot;dict.label&quot;              :value=&quot;parseInt(dict.value)&quot;            &gt;&lt;/el-option&gt;          &lt;/el-select&gt;        &lt;/el-form-item&gt;        &lt;el-divider content-position=&quot;center&quot;&gt;菜品口味关系信息&lt;/el-divider&gt;        &lt;el-row :gutter=&quot;10&quot; class=&quot;mb8&quot;&gt;          &lt;el-col :span=&quot;1.5&quot;&gt;            &lt;el-button type=&quot;primary&quot; icon=&quot;Plus&quot; @click=&quot;handleAddDishFlavor&quot;&gt;添加&lt;/el-button&gt;          &lt;/el-col&gt;          &lt;el-col :span=&quot;1.5&quot;&gt;            &lt;el-button type=&quot;danger&quot; icon=&quot;Delete&quot; @click=&quot;handleDeleteDishFlavor&quot;&gt;删除&lt;/el-button&gt;          &lt;/el-col&gt;        &lt;/el-row&gt;        &lt;el-table :data=&quot;dishFlavorList&quot; :row-class-name=&quot;rowDishFlavorIndex&quot; @selection-change=&quot;handleDishFlavorSelectionChange&quot; ref=&quot;dishFlavor&quot;&gt;          &lt;el-table-column type=&quot;selection&quot; width=&quot;50&quot; align=&quot;center&quot; /&gt;          &lt;el-table-column label=&quot;序号&quot; align=&quot;center&quot; prop=&quot;index&quot; width=&quot;50&quot;/&gt;          &lt;el-table-column label=&quot;口味名称&quot; prop=&quot;name&quot; width=&quot;150&quot;&gt;            &lt;template #default=&quot;scope&quot;&gt;              &lt;!-- &lt;el-input v-model=&quot;scope.row.name&quot; placeholder=&quot;请输入口味名称&quot; /&gt; --&gt;              &lt;el-select v-model=&quot;scope.row.name&quot; placeholder=&quot;请选择口味名称&quot;              @change=&quot;changeFlavorName(scope.row)&quot; &gt;                &lt;el-option                  v-for=&quot;dishFlavor in dishFlavorListSelect&quot;                  :key=&quot;dishFlavor.name&quot;                  :label=&quot;dishFlavor.name&quot;                  :value=&quot;dishFlavor.name&quot;                /&gt;              &lt;/el-select&gt;            &lt;/template&gt;          &lt;/el-table-column&gt;          &lt;el-table-column label=&quot;口味列表&quot; prop=&quot;value&quot; width=&quot;350&quot;&gt;            &lt;template #default=&quot;scope&quot;&gt;              &lt;!-- &lt;el-input v-model=&quot;scope.row.value&quot; placeholder=&quot;请输入口味列表&quot; /&gt; --&gt;              &lt;el-select v-model=&quot;scope.row.value&quot; placeholder=&quot;请选择口味列表&quot; multiple              @focus=&quot;focusFlavorName(scope.row)&quot; style=&quot;width: 90%;&quot;&gt;                &lt;el-option                  v-for=&quot;value in checkValueList&quot;                  :key=&quot;value&quot;                  :label=&quot;value&quot;                  :value=&quot;value&quot;                /&gt;              &lt;/el-select&gt;            &lt;/template&gt;          &lt;/el-table-column&gt;        &lt;/el-table&gt;      &lt;/el-form&gt;      &lt;template #footer&gt;        &lt;div class=&quot;dialog-footer&quot;&gt;          &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm&quot;&gt;确 定&lt;/el-button&gt;          &lt;el-button @click=&quot;cancel&quot;&gt;取 消&lt;/el-button&gt;        &lt;/div&gt;      &lt;/template&gt;    &lt;/el-dialog&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup name=&quot;Dish&quot;&gt;import &#123; listDish, getDish, delDish, addDish, updateDish &#125; from &quot;@/api/merchant/dish&quot;;import &#123; ref &#125; from &quot;vue&quot;;const &#123; proxy &#125; = getCurrentInstance();const &#123; dish_status &#125; = proxy.useDict(&#x27;dish_status&#x27;);const dishList = ref([]);const dishFlavorList = ref([]);const open = ref(false);const loading = ref(true);const showSearch = ref(true);const ids = ref([]);const checkedDishFlavor = ref([]);const single = ref(true);const multiple = ref(true);const total = ref(0);const title = ref(&quot;&quot;);const data = reactive(&#123;  form: &#123;&#125;,  queryParams: &#123;    pageNum: 1,    pageSize: 10,    name: null,    status: null,  &#125;,  rules: &#123;    name: [      &#123; required: true, message: &quot;菜品名称不能为空&quot;, trigger: &quot;blur&quot; &#125;    ],    price: [      &#123; required: true, message: &quot;售价不能为空&quot;, trigger: &quot;blur&quot; &#125;    ],    image: [      &#123; required: true, message: &quot;图片不能为空&quot;, trigger: &quot;blur&quot; &#125;    ],    status: [      &#123; required: true, message: &quot;售卖状态不能为空&quot;, trigger: &quot;change&quot; &#125;    ],  &#125;&#125;);const &#123; queryParams, form, rules &#125; = toRefs(data);//-----------------------------// 定义口味名称和口味列表静态数据const dishFlavorListSelect=ref([  &#123;name:&quot;辣度&quot;,value:[&quot;不辣&quot;,&quot;微辣&quot;,&quot;中辣&quot;,&quot;重辣&quot;]&#125;,  &#123;name:&quot;忌口&quot;,value:[&quot;不要葱&quot;,&quot;不要蒜&quot;,&quot;不要香菜&quot;,&quot;不要辣&quot;]&#125;,  &#123;name:&quot;甜味&quot;,value:[&quot;无糖&quot;,&quot;少糖&quot;,&quot;半糖&quot;,&quot;多糖&quot;]&#125;]);// 存储当前选中口味列表数组const checkValueList=ref([]);// 定义改变口味名称时更新当前选中的口味列表function changeFlavorName(row)&#123;  // 清空当前行value  row.value=[];  // 根据选中name去查找静态数据的value  checkValueList.value=dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;&#125;// 定义口味列表获取焦点时更新当前选中的口味列表function focusFlavorName(row)&#123;  // 根据选中name去查找静态数据的value  checkValueList.value=dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;&#125;//-----------------------------/** 查询菜品管理列表 */function getList() &#123;  loading.value = true;  listDish(queryParams.value).then(response =&gt; &#123;    dishList.value = response.rows;    total.value = response.total;    loading.value = false;  &#125;);&#125;// 取消按钮function cancel() &#123;  open.value = false;  reset();&#125;// 表单重置function reset() &#123;  form.value = &#123;    id: null,    name: null,    price: null,    image: null,    description: null,    status: null,    createTime: null,    updateTime: null  &#125;;  dishFlavorList.value = [];  proxy.resetForm(&quot;dishRef&quot;);&#125;/** 搜索按钮操作 */function handleQuery() &#123;  queryParams.value.pageNum = 1;  getList();&#125;/** 重置按钮操作 */function resetQuery() &#123;  proxy.resetForm(&quot;queryRef&quot;);  handleQuery();&#125;// 多选框选中数据function handleSelectionChange(selection) &#123;  ids.value = selection.map(item =&gt; item.id);  single.value = selection.length != 1;  multiple.value = !selection.length;&#125;/** 新增按钮操作 */function handleAdd() &#123;  reset();  open.value = true;  title.value = &quot;添加菜品管理&quot;;&#125;/** 修改按钮操作 */function handleUpdate(row) &#123;  reset();  const _id = row.id || ids.value  getDish(_id).then(response =&gt; &#123;    form.value = response.data;    dishFlavorList.value = response.data.dishFlavorList;    // 将口味列表value字符串转为json数组    if(dishFlavorList.value!=null)&#123;      dishFlavorList.value.forEach(item =&gt; &#123;      item.value = JSON.parse(item.value);    &#125;);    &#125;    open.value = true;    title.value = &quot;修改菜品管理&quot;;  &#125;);&#125;/** 提交按钮 */function submitForm() &#123;  proxy.$refs[&quot;dishRef&quot;].validate(valid =&gt; &#123;    if (valid) &#123;      form.value.dishFlavorList = dishFlavorList.value;      // 将口味列表中value通过JSON工具类转为字符串      if(form.value.dishFlavorList!=null)&#123;        form.value.dishFlavorList.forEach(item=&gt;&#123;        item.value = JSON.stringify(item.value)      &#125;)      &#125;          if (form.value.id != null) &#123;        updateDish(form.value).then(response =&gt; &#123;          proxy.$modal.msgSuccess(&quot;修改成功&quot;);          open.value = false;          getList();        &#125;);      &#125; else &#123;        addDish(form.value).then(response =&gt; &#123;          proxy.$modal.msgSuccess(&quot;新增成功&quot;);          open.value = false;          getList();        &#125;);      &#125;    &#125;  &#125;);&#125;/** 删除按钮操作 */function handleDelete(row) &#123;  const _ids = row.id || ids.value;  proxy.$modal.confirm(&#x27;是否确认删除菜品管理编号为&quot;&#x27; + _ids + &#x27;&quot;的数据项？&#x27;).then(function() &#123;    return delDish(_ids);  &#125;).then(() =&gt; &#123;    getList();    proxy.$modal.msgSuccess(&quot;删除成功&quot;);  &#125;).catch(() =&gt; &#123;&#125;);&#125;/** 菜品口味关系序号 */function rowDishFlavorIndex(&#123; row, rowIndex &#125;) &#123;  row.index = rowIndex + 1;&#125;/** 菜品口味关系添加按钮操作 */function handleAddDishFlavor() &#123;  let obj = &#123;&#125;;  obj.name = &quot;&quot;;  obj.value = &quot;&quot;;  dishFlavorList.value.push(obj);&#125;/** 菜品口味关系删除按钮操作 */function handleDeleteDishFlavor() &#123;  if (checkedDishFlavor.value.length == 0) &#123;    proxy.$modal.msgError(&quot;请先选择要删除的菜品口味关系数据&quot;);  &#125; else &#123;    const dishFlavors = dishFlavorList.value;    const checkedDishFlavors = checkedDishFlavor.value;    dishFlavorList.value = dishFlavors.filter(function(item) &#123;      return checkedDishFlavors.indexOf(item.index) == -1    &#125;);  &#125;&#125;/** 复选框选中数据 */function handleDishFlavorSelectionChange(selection) &#123;  checkedDishFlavor.value = selection.map(item =&gt; item.index)&#125;/** 导出按钮操作 */function handleExport() &#123;  proxy.download(&#x27;merchant/dish/export&#x27;, &#123;    ...queryParams.value  &#125;, `dish_$&#123;new Date().getTime()&#125;.xlsx`)&#125;getList();&lt;/script&gt;
图片上传组件由于之前的图片访问是本地的路径和服务，需要发起请求才能获取图片，现在我们使用了OSS，图片可直接访问，无需再次访问后端服务，所以前端的图片访问逻辑我们需要修改

修改文件位置：src/components/imageUpload/index.vue
如果图片路径是以http开头的，则不走后台服务访问，直接访问OSS，之前的不变，如下图

 
页面调整如果使用若依框架项目做为脚手架，那么我们肯定需要在页面显示中，符合自己公司或者项目的标识才行，需要更换的地方很多，我们依次来解决它

浏览器标签页logo标识、标题
系统页面中的logo标识、标题
去除源码地址 &amp; 文档地址
主题风格和菜单图标
登录名称及背景图

   
 
浏览器标签页icon、标题找到资料中的logo图标，替换前端项目中的public文件夹，删除原有的favicon.ico，把新拷贝过来的logo更名为favicon.ico即可
 
找到根目录下的index.html文件，把title更换为自己想要的内容即可
 
系统页面中的logo、标题找到资料中的logo文件，替换 src//assets/logo/logo.png文件
 
若依的系统页面标题引用的是开发环境的配置，我们只需要修改开发的环境的VITE_APP_TITLE属性即可
 
去除源码 &amp; 文档 
主题和自定义图标在目前的前端项目中，已经提供了非常便利的操作方式，可以切换主题的风格
操作：点击右上角的头像，可以找到布局设置，如下操作
 
在前端代码中也有对应的操作，更好主题风格文件位置：src/setting.js
 
更换主题颜色文件位置：src/store/modules/settings.js
 
访问阿里巴巴矢量图库，搜索图标：https://www.iconfont.cn/search/index?searchType=icon&amp;q=%E8%8F%9C%E5%93%81%E7%AE%A1%E7%90%86
 
将下载好的图标复制到src//assets/icons/svg目录下，就可以给指定菜单设置图标了
 
登录页面中标题、背景图登录名称和背景图，我们可以直接找到登录的组件进行修改即可
组件位置：src/views/login.vue
 
 
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
